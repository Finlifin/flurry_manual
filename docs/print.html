<!DOCTYPE HTML>
<html lang="en" class="light sidebar-visible" dir="ltr">
    <head>
        <!-- Book generated using mdBook -->
        <meta charset="UTF-8">
        <title>Flurry语言手册</title>
        <meta name="robots" content="noindex">


        <!-- Custom HTML head -->

        <meta name="description" content="">
        <meta name="viewport" content="width=device-width, initial-scale=1">
        <meta name="theme-color" content="#ffffff">

        <link rel="icon" href="favicon.svg">
        <link rel="shortcut icon" href="favicon.png">
        <link rel="stylesheet" href="css/variables.css">
        <link rel="stylesheet" href="css/general.css">
        <link rel="stylesheet" href="css/chrome.css">
        <link rel="stylesheet" href="css/print.css" media="print">

        <!-- Fonts -->
        <link rel="stylesheet" href="FontAwesome/css/font-awesome.css">
        <link rel="stylesheet" href="fonts/fonts.css">

        <!-- Highlight.js Stylesheets -->
        <link rel="stylesheet" id="highlight-css" href="highlight.css">
        <link rel="stylesheet" id="tomorrow-night-css" href="tomorrow-night.css">
        <link rel="stylesheet" id="ayu-highlight-css" href="ayu-highlight.css">

        <!-- Custom theme stylesheets -->


        <!-- Provide site root and default themes to javascript -->
        <script>
            const path_to_root = "";
            const default_light_theme = "light";
            const default_dark_theme = "navy";
        </script>
        <!-- Start loading toc.js asap -->
        <script src="toc.js"></script>
    </head>
    <body>
    <div id="body-container">
        <!-- Work around some values being stored in localStorage wrapped in quotes -->
        <script>
            try {
                let theme = localStorage.getItem('mdbook-theme');
                let sidebar = localStorage.getItem('mdbook-sidebar');

                if (theme.startsWith('"') && theme.endsWith('"')) {
                    localStorage.setItem('mdbook-theme', theme.slice(1, theme.length - 1));
                }

                if (sidebar.startsWith('"') && sidebar.endsWith('"')) {
                    localStorage.setItem('mdbook-sidebar', sidebar.slice(1, sidebar.length - 1));
                }
            } catch (e) { }
        </script>

        <!-- Set the theme before any content is loaded, prevents flash -->
        <script>
            const default_theme = window.matchMedia("(prefers-color-scheme: dark)").matches ? default_dark_theme : default_light_theme;
            let theme;
            try { theme = localStorage.getItem('mdbook-theme'); } catch(e) { }
            if (theme === null || theme === undefined) { theme = default_theme; }
            const html = document.documentElement;
            html.classList.remove('light')
            html.classList.add(theme);
            html.classList.add("js");
        </script>

        <input type="checkbox" id="sidebar-toggle-anchor" class="hidden">

        <!-- Hide / unhide sidebar before it is displayed -->
        <script>
            let sidebar = null;
            const sidebar_toggle = document.getElementById("sidebar-toggle-anchor");
            if (document.body.clientWidth >= 1080) {
                try { sidebar = localStorage.getItem('mdbook-sidebar'); } catch(e) { }
                sidebar = sidebar || 'visible';
            } else {
                sidebar = 'hidden';
            }
            sidebar_toggle.checked = sidebar === 'visible';
            html.classList.remove('sidebar-visible');
            html.classList.add("sidebar-" + sidebar);
        </script>

        <nav id="sidebar" class="sidebar" aria-label="Table of contents">
            <!-- populated by js -->
            <mdbook-sidebar-scrollbox class="sidebar-scrollbox"></mdbook-sidebar-scrollbox>
            <noscript>
                <iframe class="sidebar-iframe-outer" src="toc.html"></iframe>
            </noscript>
            <div id="sidebar-resize-handle" class="sidebar-resize-handle">
                <div class="sidebar-resize-indicator"></div>
            </div>
        </nav>

        <div id="page-wrapper" class="page-wrapper">

            <div class="page">
                <div id="menu-bar-hover-placeholder"></div>
                <div id="menu-bar" class="menu-bar sticky">
                    <div class="left-buttons">
                        <label id="sidebar-toggle" class="icon-button" for="sidebar-toggle-anchor" title="Toggle Table of Contents" aria-label="Toggle Table of Contents" aria-controls="sidebar">
                            <i class="fa fa-bars"></i>
                        </label>
                        <button id="theme-toggle" class="icon-button" type="button" title="Change theme" aria-label="Change theme" aria-haspopup="true" aria-expanded="false" aria-controls="theme-list">
                            <i class="fa fa-paint-brush"></i>
                        </button>
                        <ul id="theme-list" class="theme-popup" aria-label="Themes" role="menu">
                            <li role="none"><button role="menuitem" class="theme" id="default_theme">Auto</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="light">Light</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="rust">Rust</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="coal">Coal</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="navy">Navy</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="ayu">Ayu</button></li>
                        </ul>
                        <button id="search-toggle" class="icon-button" type="button" title="Search. (Shortkey: s)" aria-label="Toggle Searchbar" aria-expanded="false" aria-keyshortcuts="S" aria-controls="searchbar">
                            <i class="fa fa-search"></i>
                        </button>
                    </div>

                    <h1 class="menu-title">Flurry语言手册</h1>

                    <div class="right-buttons">
                        <a href="print.html" title="Print this book" aria-label="Print this book">
                            <i id="print-button" class="fa fa-print"></i>
                        </a>

                    </div>
                </div>

                <div id="search-wrapper" class="hidden">
                    <form id="searchbar-outer" class="searchbar-outer">
                        <input type="search" id="searchbar" name="searchbar" placeholder="Search this book ..." aria-controls="searchresults-outer" aria-describedby="searchresults-header">
                    </form>
                    <div id="searchresults-outer" class="searchresults-outer hidden">
                        <div id="searchresults-header" class="searchresults-header"></div>
                        <ul id="searchresults">
                        </ul>
                    </div>
                </div>

                <!-- Apply ARIA attributes after the sidebar and the sidebar toggle button are added to the DOM -->
                <script>
                    document.getElementById('sidebar-toggle').setAttribute('aria-expanded', sidebar === 'visible');
                    document.getElementById('sidebar').setAttribute('aria-hidden', sidebar !== 'visible');
                    Array.from(document.querySelectorAll('#sidebar a')).forEach(function(link) {
                        link.setAttribute('tabIndex', sidebar === 'visible' ? 0 : -1);
                    });
                </script>

                <div id="content" class="content">
                    <main>
                        <h1 id="flurry-为下一代基础设施而生"><a class="header" href="#flurry-为下一代基础设施而生">Flurry: 为下一代基础设施而生</a></h1>
<p>欢迎来到 Flurry 的世界！Flurry 并非又一个通用编程语言，它的诞生承载着一个明确的使命：为构建未来<strong>高性能、高可靠性、高安全性</strong>的计算基础设施提供坚实的基础。</p>
<h2 id="问题域系统编程的困境"><a class="header" href="#问题域系统编程的困境">问题域：系统编程的困境</a></h2>
<p>现代数字世界的基石——操作系统、网络协议栈、数据库、虚拟机、云平台——都依赖于系统级编程语言来构建。这些基础设施软件对正确性、性能和资源利用率有着极致的要求。然而，长期以来，主流的系统级语言，特别是 C 和 C++，虽然赋予了开发者无与伦比的底层控制能力，但也因其固有的内存安全问题和并发处理复杂性，成为了无数严重软件缺陷和安全漏洞的温床 <sup class="footnote-reference" id="fr-1-1"><a href="#footnote-1">1</a></sup>。</p>
<p>近年来，像 Rust 这样的语言通过引入所有权和借用检查等创新机制，在编译时提供了强大的内存和线程安全保证，极大地改善了现状。但这并非终点。为了实现必要的底层控制和极致性能，即使是 Rust 也需要 <code>unsafe</code> 代码块，这道“后门”重新引入了对形式化验证的需求，以确保安全边界的稳固<sup class="footnote-reference" id="fr-2-1"><a href="#footnote-2">2</a></sup>。此外，仅仅保证内存和线程安全是不够的，基础设施软件还需要深层次的<strong>功能正确性</strong>——即程序必须精确地按照其复杂规范运行。现有的验证技术在面对系统编程的复杂性（指针算术、细粒度并发、硬件交互、复杂的别名）时，往往捉襟见肘<sup class="footnote-reference" id="fr-3-1"><a href="#footnote-3">3</a></sup>。</p>
<p>我们相信，是时候需要一种新的系统级编程语言了——它不仅要提供现代语言的安全性与开发效率，还要在设计之初就<strong>内建对高级验证和复杂系统建模的支持</strong>，并提供无与伦比的<strong>编译时能力</strong>来消除抽象开销和实现深度优化。</p>
<h2 id="flurry-的答案安全性能与表现力的融合"><a class="header" href="#flurry-的答案安全性能与表现力的融合">Flurry 的答案：安全、性能与表现力的融合</a></h2>
<p>Flurry 正是为此而设计的。它旨在成为构建下一代操作系统、网络栈、数据库内核、嵌入式系统以及其他关键基础设施的理想选择。Flurry 的核心理念是在以下几个关键维度上取得突破性的进展：</p>
<ol>
<li>
<p><strong>内建安全性与验证支持</strong>:</p>
<ul>
<li><strong>分级安全模型</strong>: 提供 <code>unsafe</code>, <code>safe</code>, <code>verified</code> 三个安全级别，允许开发者明确风险并逐步提升代码可信度。</li>
<li><strong>创新的安全机制</strong>: 超越传统借用检查，探索结合<strong>仿射类型、可达性类型系统和副作用系统</strong>，旨在提供灵活且强大的静态安全保证。</li>
<li><strong>面向验证的设计</strong>: 语言核心特性（如代数效应、<code>comptime</code> 元编程）的设计考虑了与形式化方法（如 Outcome Separation Logic, Reachability Logic, Matching Logic）的集成可能性，目标是让深度验证更加可行。</li>
</ul>
</li>
<li>
<p><strong>极致的编译时能力 (<code>comptime</code>)</strong>:</p>
<ul>
<li><strong>图灵完备的编译时执行</strong>: Flurry 拥有一个功能强大的编译时运行时，允许在编译阶段执行任意复杂的计算、代码生成和静态检查。</li>
<li><strong>零成本抽象</strong>: 泛型、元编程和高级抽象通过编译时计算实现单态化和优化，不引入运行时开销。</li>
<li><strong>编译时配置与构建</strong>: 包管理、特性标志、甚至构建逻辑都可以使用 Flurry 自身的 <code>comptime</code> 代码定义，提供无与伦比的灵活性。</li>
</ul>
</li>
<li>
<p><strong>富有表现力且一致的语法</strong>:</p>
<ul>
<li><strong>现代特性</strong>: 吸收并改进了代数效应、强大的模式匹配、Trait 系统、层级化枚举等现代语言特性。</li>
<li><strong>创新语法</strong>: 引入 <code>expr object</code> DSL 构建、<code>expr ' image</code> 取像、<code>extend</code> 作用域扩展、<code>.tagged_polymorphic</code> 多态等独特语法，旨在提升特定场景下的表达力和简洁性。</li>
<li><strong>一致性</strong>: 追求语法元素（如 <code>.</code>, <code>^</code>, <code>'</code>）在不同上下文中的一致语义。</li>
</ul>
</li>
<li>
<p><strong>性能与控制力</strong>:</p>
<ul>
<li><strong>系统级定位</strong>: 提供必要的底层控制能力（如指针操作，但需在 <code>unsafe</code> 中或得到验证）。</li>
<li><strong>面向性能的设计</strong>: 编译时计算、潜在的优化（如 <code>tagged_polymorphic</code> 分派）都旨在生成高效的本地代码。</li>
</ul>
</li>
</ol>
<h2 id="为什么选择-flurryteaser"><a class="header" href="#为什么选择-flurryteaser">为什么选择 Flurry？(Teaser)</a></h2>
<ul>
<li><strong>超越 Rust 的安全边界</strong>: 在提供 <code>safe</code> 基础的同时，为 <code>unsafe</code> 和功能正确性提供内建的、更强大的验证路径。</li>
<li><strong>Zig 级别的编译时能力，甚至更强</strong>: <code>comptime</code> 是 Flurry 的核心支柱，深度集成到类型系统、元编程和构建过程中。</li>
<li><strong>代数效应带来的结构化并发与控制流</strong>: 提供比传统回调、Promise、async/await 更灵活、更可组合的副作用和控制流管理。</li>
<li><strong>独特的 DSL 构建能力</strong>: <code>expr object</code> 和 <code>extend</code> 字面量拓展等特性使得构建嵌入式领域特定语言极其自然。</li>
<li><strong>为复杂系统而生的模块化与验证支持</strong>: 从包管理到形式化方法集成，都旨在应对大型、关键系统的挑战。</li>
</ul>
<p>Flurry 是一项雄心勃勃的探索，它试图站在现有系统语言的肩膀上，融合最新的编程语言理论研究，为未来构建更安全、更可靠、更高效的数字基础设施提供下一代利器。我们邀请您一同踏上这段激动人心的旅程！</p>
<hr />
<hr>
<ol class="footnote-definition"><li id="footnote-1">
<p>Memory-Safe Programming Languages and National Cybersecurity ... <a href="#fr-1-1">↩</a></p>
</li>
<li id="footnote-2">
<p>Surveying the Rust Verification Landscape - arXiv <a href="#fr-2-1">↩</a></p>
</li>
<li id="footnote-3">
<p>Concurrent Separation Logic <a href="#fr-3-1">↩</a></p>
</li>
</ol><div style="break-before: page; page-break-before: always;"></div><h1 id="快速入门"><a class="header" href="#快速入门">快速入门</a></h1>
<p>本章旨在让您快速领略 Flurry 语言的风采。我们将通过一个简单的示例展示 Flurry 的一些核心特性，并指导您完成基本的安装和运行流程。我们的目标不是详尽解释所有细节，而是让您对 Flurry 的编程体验有一个初步的感受。</p>
<h2 id="hello-infrastructure---一个-flurry-示例"><a class="header" href="#hello-infrastructure---一个-flurry-示例">"Hello, Infrastructure!" - 一个 Flurry 示例</a></h2>
<p>让我们来看一个稍微超越传统 "Hello, World!" 的例子，它将触及 Flurry 的编译时计算和可选类型：</p>
<pre><code class="language-flurry">-- src/main.fl

-- 使用标准库的打印功能
use std.io.println;
-- 使用构建信息模块 (假设存在)
use build;

-- 定义一个编译时常量，存储构建目标操作系统
const TARGET_OS: str = comptime build.target.os'tag_name; -- 取像操作获取 tag 名

-- 程序入口点 main 函数
pub fn main() -&gt; void {
    let user_name: ?String = get_user_from_env(); -- 返回可选类型 ?String

    -- 编译时条件分支 (inline if)
    inline if TARGET_OS == "windows" {
        println("Detected Windows!");
    } else if TARGET_OS == "linux" {
        println("Running on Linux!");
    } else {
        println("Running on an unknown OS: {str}", TARGET_OS); -- 字符串插值
    }

    -- 处理可选类型
    if user_name is {
        some name =&gt; { -- 模式匹配解构 Some
            println("Hello, {str}!", name); -- {str} 是格式化说明符
        }
        null =&gt; { -- 匹配 null
            println("Hello, anonymous user!");
        }
    }
}

-- 假设的函数，从环境变量获取用户名，可能失败
fn get_user_from_env() -&gt; ?String {
    -- ... (实际实现会读取环境变量) ...
    -- 模拟可能找到或找不到
    if std.random.bool() { -- 假设有随机库
         "FlurryDev".to_string() -- 返回 String，自动提升为 ?String
    } else {
         null -- 返回 null
    }
}

</code></pre>
<p><strong>这个简单的例子展示了:</strong></p>
<ul>
<li><strong>模块导入 (<code>use</code>)</strong>: 如何引入外部模块的功能。</li>
<li><strong>编译时计算 (<code>comptime</code>)</strong>: 如何在编译时获取信息（如构建目标）并将其用于代码逻辑。</li>
<li><strong>取像操作 (<code>'tag_name</code>)</strong>: 如何获取一个值（这里是编译时符号）的元信息。</li>
<li><strong>编译时条件 (<code>inline if</code>)</strong>: 如何根据编译时条件选择性地包含代码。</li>
<li><strong>可选类型 (<code>?String</code>)</strong>: 如何表示可能不存在的值。</li>
<li><strong>模式匹配 (<code>if is { some =&gt; ..., null =&gt; ... }</code>)</strong>: 如何安全地处理可选类型。</li>
<li><strong>字符串插值 (<code>"{str}"</code>, <code>$variable</code>)</strong>: (假设 <code>${}</code> 用于编译时插值，<code>{str}</code> 用于运行时格式化)。</li>
<li><strong>自动类型提升</strong>: <code>String</code> 和 <code>null</code> 如何根据函数返回类型 <code>?String</code> 自动提升。</li>
</ul>
<h2 id="核心特性概览-亮点速览"><a class="header" href="#核心特性概览-亮点速览">核心特性概览 (亮点速览)</a></h2>
<p>除了上面的例子，Flurry 还拥有更多令人兴奋的特性：</p>
<ul>
<li><strong>代数效应 (Algebraic Effects)</strong>: 以结构化、可组合的方式处理 IO、并发、错误等副作用。
<pre><code class="language-flurry">effect Ask(question: String) -&gt; String; -- 定义效应
fn greet() -&gt; #Ask void { -- 标记函数可能发出 Ask 效应
    let name = perform Ask("What's your name?"); -- 发出效应
    println("Hello, {str}!", name);
}
greet() # { -- 提供 Handler
    Ask(q) =&gt; { println("Answering: {str}", q); resume "Flurry"; } -- 处理效应并恢复
}
</code></pre>
</li>
<li><strong>强大的模式匹配</strong>: 超越简单的值匹配，支持解构、范围、守卫、类型匹配等。
<pre><code class="language-flurry">match response {
    { status: 200, body } =&gt; process_ok(body),
    { status: 404 } =&gt; log_not_found(),
    { status: 4xx } if is_client_error(status) =&gt; handle_client_error(status), -- 范围/通配符与守卫
    _ =&gt; handle_other_error(),
}
</code></pre>
</li>
<li><strong><code>expr object</code> DSL 构建</strong>: 以极其声明式的方式构建复杂数据结构。
<pre><code class="language-flurry">-- (之前 Web API 示例中的查询或响应构建)
let query = Product.query {
    .limit 10,
    .sort "price",
    .filter &lt;{ category: "books", price: ..100.0 }&gt;, -- &lt;{...}&gt; 模式字面量
}
</code></pre>
</li>
<li><strong><code>extend</code> 与字面量拓展</strong>:
<pre><code class="language-flurry">extend u64 { fn kb(self) -&gt; usize { self * 1024 } }
let buffer_size = 4kb; -- 等于 4 * 1024
</code></pre>
</li>
<li><strong>类型即代码 (<code>comptime</code>)</strong>: 在编译时操作类型、生成代码。
<pre><code class="language-flurry">-- 生成特定大小的数组类型
comptime let MyArrayType = Type.Array(i32, 10);
let arr: MyArrayType = uninitialized;
</code></pre>
</li>
</ul>
<p>这仅仅是冰山一角！Flurry 的设计充满了各种精心设计的特性，旨在让系统编程更安全、更高效、更富有表现力。</p>
<h2 id="安装与运行-暂定"><a class="header" href="#安装与运行-暂定">安装与运行 (暂定)</a></h2>
<p><em>TODO: 在此部分添加关于如何获取 Flurry 编译器/工具链（例如，下载预编译版本、从源码构建）、设置开发环境以及编译运行第一个示例（<code>hello_infrastructure</code>）的具体步骤。</em></p>
<p>例如：</p>
<ol>
<li><strong>下载</strong>: 前往 <a href="introduction/link-to-flurry-repo-or-website">Flurry 官方网站/仓库</a> 下载最新的编译器。</li>
<li><strong>安装</strong>: 解压或运行安装程序，并将 Flurry 可执行文件路径添加到系统 <code>PATH</code>。</li>
<li><strong>验证</strong>: 打开终端，运行 <code>flurry --version</code> 确认安装成功。</li>
<li><strong>创建项目</strong>: <code>mkdir hello_flurry &amp;&amp; cd hello_flurry</code></li>
<li><strong>创建 <code>src/main.fl</code></strong>: 将上面的示例代码粘贴进去。</li>
<li><strong>创建 <code>package.fl</code></strong> (最简形式，假设需要)：
<pre><code class="language-flurry">-- package.fl
{ .name "hello_flurry", .type .exe }
</code></pre>
</li>
<li><strong>编译</strong>: <code>flurry build</code></li>
<li><strong>运行</strong>: <code>.build/hello_flurry</code> (或 Windows 上的 <code>.build\hello_flurry.exe</code>)</li>
</ol>
<p>(以上步骤是假设性的，需要根据实际的工具链进行调整。)</p>
<p>现在，您已经对 Flurry 有了初步的认识。准备好深入探索了吗？接下来的章节将带您详细了解 Flurry 的各项核心特性。</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="第-3-章基础语法与数据类型"><a class="header" href="#第-3-章基础语法与数据类型">第 3 章：基础语法与数据类型</a></h1>
<p>欢迎进入 Flurry 语言的核心基础。本章将引导您熟悉构成 Flurry 程序骨架的基本元素：词法结构、如何表示常量值（字面量）、语言内建的基本数据类型，以及 Flurry 特有的符号类型。理解这些基础构件是掌握 Flurry 编程的第一步。</p>
<p>Flurry 的设计在语法层面力求简洁和一致性，同时也引入了一些独特的规则（如运算符的空格敏感性和特定情况下的分号省略）来提升代码的可读性和减少歧义。</p>
<p>本章包含以下内容：</p>
<ul>
<li><strong><a href="core/core/basics/lexical.html">词法结构</a></strong>: 介绍构成 Flurry 代码的基本单元，如标识符、关键字、运算符和注释的规则。</li>
<li><strong><a href="core/core/basics/literals.html">字面量详解</a></strong>: 详细探讨如何在 Flurry 中表示整数、浮点数、字符、字符串、布尔值以及符号等固定值。</li>
<li><strong><a href="core/core/basics/primitives.html">基本数据类型</a></strong>: 概述 Flurry 提供的内建原子数据类型，它们是构建更复杂数据结构的基础。</li>
<li><strong><a href="core/core/basics/symbols.html">符号</a></strong>: 深入了解 Flurry 中独特的符号类型及其用途。</li>
</ul>
<p>掌握这些基础知识，将为您后续学习 Flurry 更强大的特性（如表达式、控制流、函数和类型系统）打下坚实的基础。</p>
<div style="break-before: page; page-break-before: always;"></div><h2 id="词法结构"><a class="header" href="#词法结构">词法结构</a></h2>
<p>Flurry 代码由一系列遵循特定规则的<strong>词法单元 (Tokens)</strong> 构成。词法分析器 (Lexer) 负责将源代码文本流分解为这些有意义的单元。理解这些基本规则有助于编写语法正确的 Flurry 代码。</p>
<h3 id="标识符-identifiers"><a class="header" href="#标识符-identifiers">标识符 (Identifiers)</a></h3>
<p>标识符用于命名变量、函数、类型、模块等。Flurry 的标识符必须遵循以下规则：</p>
<ul>
<li>以<strong>字母</strong> (a-z, A-Z) 或<strong>下划线</strong> (<code>_</code>) 开头。</li>
<li>开头字符后可以跟任意数量的<strong>字母</strong>、<strong>数字</strong> (0-9) 或<strong>下划线</strong>。</li>
<li>标识符是<strong>大小写敏感</strong>的（<code>myVariable</code> 和 <code>myvariable</code> 是不同的标识符）。</li>
</ul>
<pre><code class="language-flurry">let user_name = "Alice"; -- 合法的标识符
const MAX_CONNECTIONS = 100;
fn _internal_helper() { ... }

-- let 1st_attempt = 0; -- 非法，不能以数字开头
-- let user-name = "Bob"; -- 非法，包含非法字符 '-'
</code></pre>
<h3 id="关键字-keywords"><a class="header" href="#关键字-keywords">关键字 (Keywords)</a></h3>
<p>关键字是 Flurry 语言保留的、具有特殊含义的标识符，不能用作普通标识符。Flurry 拥有一套精心设计的关键字集合，以支持其丰富的特性。</p>
<p><em>TODO: 在此列出 Flurry 的完整关键字列表，或链接到附录中的关键字参考。</em></p>
<p>例如，<code>fn</code>, <code>let</code>, <code>const</code>, <code>struct</code>, <code>enum</code>, <code>if</code>, <code>else</code>, <code>while</code>, <code>for</code>, <code>use</code>, <code>mod</code>, <code>comptime</code>, <code>impl</code>, <code>trait</code>, <code>unsafe</code> 等都是 Flurry 的关键字。</p>
<h3 id="运算符-operators"><a class="header" href="#运算符-operators">运算符 (Operators)</a></h3>
<p>Flurry 支持多种运算符，用于执行算术、逻辑、比较、赋值等操作。一些常见的运算符包括 <code>+</code>, <code>-</code>, <code>*</code>, <code>/</code>, <code>%</code>, <code>==</code>, <code>!=</code>, <code>&lt;</code>, <code>&gt;</code>, <code>&lt;=</code>, <code>&gt;=</code>, <code>=</code>, <code>.</code> 等。</p>
<p><strong>空格敏感性</strong>: Flurry 对某些<strong>二元</strong>运算符（<code>+</code>, <code>-</code>, <code>/</code>, <code>*</code>, <code>%</code>, <code>&lt;</code>, <code>&gt;</code>）引入了<strong>空格敏感性</strong>规则，以减少歧义（特别是泛型尖括号 <code>&lt;</code> <code>&gt;</code> 与比较运算符的混淆）：</p>
<ul>
<li>当这些运算符<strong>两侧都有空格</strong>时，它们被识别为标准的二元算术或比较运算符。
<pre><code class="language-flurry">let sum = a + b;
let is_greater = x &gt; y;
</code></pre>
</li>
<li>如果<strong>至少一侧没有空格</strong>，它们会被词法分析器识别为不同的 token（例如，用于泛型或模板的尖括号）。
<pre><code class="language-flurry">let list: Vec&lt;i32&gt;; -- '&lt;' 和 '&gt;' 两侧无空格，被识别为泛型分隔符
-- a+b -- 词法分析器可能不会将其识别为标准加法
</code></pre>
</li>
</ul>
<p>这项规则鼓励开发者在二元运算中使用空格，提高代码可读性，并在词法层面解决常见的解析冲突。</p>
<h3 id="注释-comments"><a class="header" href="#注释-comments">注释 (Comments)</a></h3>
<p>注释用于在代码中添加说明，它们会被编译器忽略。Flurry 支持两种类型的注释：</p>
<ul>
<li><strong>行注释 (Line Comment)</strong>: 以 <code>--</code> 开始，直到行尾。
<pre><code class="language-flurry">-- 这是一个行注释
let timeout = 1000; -- 设置超时时间 (毫秒)
</code></pre>
</li>
<li><strong>块注释 (Block Comment)</strong>: 以 <code>{-</code> 开始，以 <code>-}</code> 结束，可以跨越多行，并且通常支持嵌套。
<pre><code class="language-flurry">{-
  这是一个块注释。
  它可以包含多行文本。
  {- 嵌套的块注释 -}
-}
let config = load_config();
</code></pre>
</li>
</ul>
<h3 id="分号-semicolons-与语句结束"><a class="header" href="#分号-semicolons-与语句结束">分号 (Semicolons) 与语句结束</a></h3>
<p>Flurry 使用分号 <code>;</code> 来分隔或结束语句。然而，为了简洁性，Flurry 引入了一条特殊的<strong>分号省略规则</strong>：</p>
<ul>
<li><strong>当一个语句的最后一个 token 的最后一个字符是右花括号 <code>}</code> 时，该语句末尾的分号可以省略。</strong></li>
</ul>
<p>这常见于代码块（函数体、结构体定义、<code>if</code> 块等）或某些复合字面量（如 <code>object</code> 字面量）的结束处。</p>
<pre><code class="language-flurry">struct Point { x: i32, y: i32 } -- '}' 结尾，可省略 ';'

fn main() {
    println("Hello"); -- ')' 结尾，不可省略 ';'
    if true {
        do_something() -- 函数体 '}' 结尾，可省略 ';'
    } -- if 语句 '}' 结尾，可省略 ';'
} -- main 函数体 '}' 结尾，可省略 ';'

let data = { .key "value" } -- object 字面量 '}' 结尾，可省略 ';'
</code></pre>
<p>在不符合此规则的情况下，语句末尾必须使用分号。这条规则旨在提高常见代码模式的视觉整洁度，但并不改变语句的基本分隔原则。</p>
<p>理解这些基本的词法规则是编写和阅读 Flurry 代码的基础。</p>
<hr />
<p>请检查这些内容是否符合您的预期，特别是关于可选参数默认 <code>null</code>、do block、编译时求值和沉降机制的暗示，以及整体的语气把握。</p>
<div style="break-before: page; page-break-before: always;"></div><h2 id="字面量详解"><a class="header" href="#字面量详解">字面量详解</a></h2>
<p>字面量 (Literals) 是源代码中直接表示固定值的文本表示。它们是构建程序逻辑和数据的基本元素。Flurry 提供了丰富且灵活的字面量语法，以精确地表示各种常见类型的值。</p>
<h3 id="1-整数-integer"><a class="header" href="#1-整数-integer">1. 整数 (Integer)</a></h3>
<p>整数用于表示没有小数部分的数值。</p>
<ul>
<li><strong>十进制 (Decimal)</strong>: 最常见的形式。
<pre><code class="language-flurry">123
0
-42
</code></pre>
</li>
<li><strong>不同进制</strong>:
<ul>
<li><strong>二进制 (Binary)</strong>: 以 <code>0b</code> 或 <code>0B</code> 开头。
<pre><code class="language-flurry">0b101010 -- == 42
0B1111_0000
</code></pre>
</li>
<li><strong>八进制 (Octal)</strong>: 以 <code>0o</code> 或 <code>0O</code> 开头。
<pre><code class="language-flurry">0o777 -- == 511
0O123_456
</code></pre>
</li>
<li><strong>十六进制 (Hexadecimal)</strong>: 以 <code>0x</code> 或 <code>0X</code> 开头。
<pre><code class="language-flurry">0xFF -- == 255
0xCafeBabe
0Xdead_beef
</code></pre>
</li>
</ul>
</li>
<li><strong>类型后缀 (Type Suffix)</strong>: 可以通过后缀指定具体的整数类型。常见的后缀包括 <code>u8</code>, <code>i32</code>, <code>u64</code>, <code>isize</code>, <code>usize</code> 等（具体可用后缀依赖于语言标准库定义）。如果省略后缀，编译器会根据上下文尝试推断类型，或使用默认类型（例如 <code>i32</code>）。
<pre><code class="language-flurry">100i32
42u8
0xFF_u64
</code></pre>
</li>
<li><strong>下划线分隔符 (<code>_</code>)</strong>: 为了提高可读性，可以在数字之间使用下划线 <code>_</code> 作为分隔符。下划线会被编译器忽略。注意，字面量的第一个字符不能是下划线（除非是负号后的第一个数字）。
<pre><code class="language-flurry">1_000_000
0b1111_0000_1010_0101
</code></pre>
</li>
</ul>
<h3 id="2-浮点数-float"><a class="header" href="#2-浮点数-float">2. 浮点数 (Float)</a></h3>
<p>浮点数用于表示可能带有小数部分的数值。</p>
<ul>
<li><strong>基本形式</strong>: 必须包含小数点 <code>.</code> 或指数标记 <code>e</code>/<code>E</code>。
<pre><code class="language-flurry">3.14159
-0.5
100.0 -- 即使小数部分为 0，也表示浮点数
1. -- 合法，等同于 1.0 (如果语法允许)
.5 -- 可能非法，通常需要小数点前有数字
</code></pre>
</li>
<li><strong>科学计数法 (Scientific Notation)</strong>: 使用 <code>e</code> 或 <code>E</code> 表示 10 的幂。
<pre><code class="language-flurry">1.23e4  -- == 12300.0
-5.67E-3 -- == -0.00567
</code></pre>
</li>
<li><strong>类型后缀 (Type Suffix)</strong>: 可以使用 <code>f32</code> 或 <code>f64</code> 后缀指定精度。如果省略，编译器通常会推断或默认使用 <code>f64</code>。
<pre><code class="language-flurry">2.718f32
-42.0f64
1e6f64 -- 1 百万，64 位浮点数
</code></pre>
</li>
<li><strong>下划线分隔符 (<code>_</code>)</strong>: 同样可用，规则与整数相同。
<pre><code class="language-flurry">3_141_592.653_589f64
1_000e-3_f32 -- == 1.0f32
</code></pre>
</li>
</ul>
<h3 id="3-字符-character"><a class="header" href="#3-字符-character">3. 字符 (Character)</a></h3>
<p>字符表示单个 Unicode 标量值，用<strong>单引号 <code>' '</code></strong> 括起来。</p>
<ul>
<li><strong>普通字符</strong>:
<pre><code class="language-flurry">'a'
'Z'
'7'
'_'
</code></pre>
</li>
<li><strong>转义序列 (Escape Sequences)</strong>: 使用反斜杠 <code>\</code> 进行转义，支持常见转义：
<ul>
<li><code>\'</code>: 单引号</li>
<li><code>\\</code>: 反斜杠</li>
<li><code>\n</code>: 换行符 (Newline)</li>
<li><code>\r</code>: 回车符 (Carriage Return)</li>
<li><code>\t</code>: 水平制表符 (Horizontal Tab)</li>
<li><em>（可能还有其他，如 <code>\0</code> 空字符等）</em></li>
</ul>
<pre><code class="language-flurry">'\'' -- 表示单引号字符
'\\' -- 表示反斜杠字符
'\n'
</code></pre>
</li>
<li><strong>Unicode 转义</strong>: 使用 <code>\x{...}</code> 形式，花括号内是 1 到 6 位的十六进制 Unicode 码点。
<pre><code class="language-flurry">'\x{41}' -- == 'A'
'\x{3A3}' -- == 'Σ' (希腊字母 Sigma)
'\x{1F600}' -- 😀 (笑脸 Emoji)
</code></pre>
</li>
</ul>
<h3 id="4-字符串-string"><a class="header" href="#4-字符串-string">4. 字符串 (String)</a></h3>
<p>字符串表示一系列字符，用<strong>双引号 <code>"</code> <code>"</code></strong> 括起来。</p>
<ul>
<li><strong>基本字符串</strong>:
<pre><code class="language-flurry">"Hello, Flurry!"
"这是一个包含 Unicode 的字符串：你好 Σ 😀"
"" -- 空字符串
</code></pre>
</li>
<li><strong>转义序列</strong>: 字符串内部支持与字符字面量相同的转义序列。
<pre><code class="language-flurry">"第一行\n第二行\t缩进"
"路径是: \"C:\\Program Files\\\""
</code></pre>
</li>
<li><strong>字面量合并 (Concatenation)</strong>: 多个相邻的字符串字面量（仅由空白分隔）会被编译器自动合并成一个单一的字符串。这对于书写长字符串或跨行书写很有用。
<pre><code class="language-flurry">let long_message = "这是第一部分, "
                   "这是第二部分, "
                   "这是最后一部分.";
-- 等价于: let long_message = "这是第一部分, 这是第二部分, 这是最后一部分.";
</code></pre>
</li>
<li><strong>原始字符串 (Raw Strings)</strong>: 对于需要包含大量特殊字符（如正则表达式、代码片段、多行文本）而无需转义的情况，可以使用原始字符串，其通过<code>builtin.raw_str</code>宏提供，<code>{}</code> 内的所有内容（包括换行符）都将按原样成为字符串的一部分。
<pre><code class="language-flurry">-- 假设语法
let regex_pattern = builtin.raw_str'{^\d{4}-\d{2}-\d{2}$}
let multi_line = builtin.raw_str'{
这是一个多行文本，
内部的 "引号" 和 \ 反斜杠
都无需转义。
}
</code></pre>
</li>
<li><strong>编译时类型</strong>: 需要特别指出的是，在 Flurry 中，<strong>字符串字面量 <code>"..."</code> 本身很可能属于编译时类型 <code>str</code></strong> (或类似的代数字符串类型)，它代表了编译时已知的文本内容。这使得它们可以用于 <code>comptime</code> 计算和字符串插值。运行时的、可变的或堆分配的字符串可能是另一种类型（例如 <code>String</code>）。</li>
<li><strong>编译时插值 (<code>$variable</code>)</strong>: 字符串字面量支持使用 <code>$identifier</code> 的形式嵌入<strong>编译时已知</strong>的变量或常量的值。
<pre><code class="language-flurry">comptime const VERSION = "0.1.0";
const MESSAGE = "Welcome to Flurry version $VERSION!";
-- MESSAGE 的值在编译时确定为 "Welcome to Flurry version 0.1.0!"
</code></pre>
注意：这与运行时的字符串格式化（例如 <code>println</code> 中使用的 <code>{}</code> 占位符）是不同的概念。</li>
<li><strong>变体后缀 (Variant Suffixes)</strong>: 字符串字面量后可以跟特定的标识符后缀来创建特殊类型的字符串表示：
<ul>
<li><code>"..."c</code> (<strong>C String Variant</strong>): 创建一个与 C 语言 ABI 兼容的字符串表示，通常意味着以空字符 (<code>\0</code>) 结尾，并可能使用特定的编码（如 UTF-8）。用于 FFI 交互。</li>
<li><code>"..."b</code> (<strong>Byte String Variant</strong>): 将字符串字面量的内容解释为一个字节序列（通常是 <code>Slice&lt;u8&gt;</code> 或类似类型），忽略其文本编码。用于处理原始二进制数据。</li>
</ul>
</li>
</ul>
<h3 id="5-布尔值-boolean"><a class="header" href="#5-布尔值-boolean">5. 布尔值 (Boolean)</a></h3>
<p>表示逻辑真或假。</p>
<ul>
<li><code>true</code>: 真</li>
<li><code>false</code>: 假</li>
</ul>
<p>它们是 Flurry 的内置布尔类型 (<code>bool</code>) 的唯二值。</p>
<h3 id="6-null-字面量"><a class="header" href="#6-null-字面量">6. <code>null</code> 字面量</a></h3>
<p><code>null</code> 是一个特殊的字面量，用于表示 Flurry 中<strong>可选类型 (<code>?T</code>)</strong> 的“无值”状态。它本身可能没有独立的类型，而是作为可选类型的特殊值存在。</p>
<pre><code class="language-flurry">let maybe_value: ?i32 = null;
</code></pre>
<h3 id="7-符号-symbol"><a class="header" href="#7-符号-symbol">7. 符号 (Symbol)</a></h3>
<p>符号是一种独特的字面量类型，以点 <code>.</code> 开头，后跟一个标识符。它们代表编译时唯一的标识符常量。具体细节将在 <a href="core/basics/core/basics/symbols.html">符号</a> 章节中讨论。</p>
<pre><code class="language-flurry">.ok
.error
.my_custom_symbol
</code></pre>
<p>掌握 Flurry 丰富而精确的字面量表示法，是有效利用其类型系统和编译时能力的基础。</p>
<div style="break-before: page; page-break-before: always;"></div><h2 id="基本数据类型"><a class="header" href="#基本数据类型">基本数据类型</a></h2>
<p>基本数据类型 (Primitive Data Types) 是 Flurry 语言内建的最原子化的数据类型。它们构成了构建所有更复杂数据结构（如结构体、枚举、数组等）的基础。Flurry 提供了一组常见的、面向系统编程需求的基本类型。</p>
<p><em>TODO: 以下列表需要基于 Flurry 的最终设计进行确认和完善。</em></p>
<h3 id="1-整数类型-integer-types"><a class="header" href="#1-整数类型-integer-types">1. 整数类型 (Integer Types)</a></h3>
<p>Flurry 旨在提供一系列固定位宽的整数类型，以进行精确的位级控制：</p>
<ul>
<li><strong>有符号整数</strong>:
<ul>
<li><code>i8</code>: 8 位有符号整数</li>
<li><code>i16</code>: 16 位有符号整数</li>
<li><code>i32</code>: 32 位有符号整数</li>
<li><code>i64</code>: 64 位有符号整数</li>
<li><code>i128</code>: 128 位有符号整数 (可选支持)</li>
<li><code>isize</code>: 指针大小的有符号整数（其位宽与目标平台的指针位宽相同，通常是 32 位或 64 位）。常用于索引和大小计算。</li>
</ul>
</li>
<li><strong>无符号整数</strong>:
<ul>
<li><code>u8</code>: 8 位无符号整数 (常用于表示字节)</li>
<li><code>u16</code>: 16 位无符号整数</li>
<li><code>u32</code>: 32 位无符号整数</li>
<li><code>u64</code>: 64 位无符号整数</li>
<li><code>u128</code>: 128 位无符号整数 (可选支持)</li>
<li><code>usize</code>: 指针大小的无符号整数。是数组索引、集合大小、内存偏移量等的首选类型。</li>
</ul>
</li>
</ul>
<h3 id="2-浮点数类型-floating-point-types"><a class="header" href="#2-浮点数类型-floating-point-types">2. 浮点数类型 (Floating-Point Types)</a></h3>
<p>用于表示带有小数的数值，遵循 IEEE 754 标准：</p>
<ul>
<li><code>f32</code>: 32 位单精度浮点数。</li>
<li><code>f64</code>: 64 位双精度浮点数。</li>
</ul>
<p>浮点数支持标准的算术运算。需要注意浮点数运算的精度问题和特殊值（如 <code>f64.NaN</code>, <code>f64.Infinity</code>）。</p>
<h3 id="3-布尔类型-boolean-type"><a class="header" href="#3-布尔类型-boolean-type">3. 布尔类型 (Boolean Type)</a></h3>
<ul>
<li><code>bool</code>: 表示逻辑值，只有两个可能的取值：<code>true</code> 和 <code>false</code>。
常用于条件判断和逻辑运算 (<code>and</code>, <code>or</code>, <code>not</code>)。</li>
</ul>
<h3 id="4-字符类型-character-type"><a class="header" href="#4-字符类型-character-type">4. 字符类型 (Character Type)</a></h3>
<ul>
<li><code>char</code>: 表示一个 Unicode 标量值 (Unicode Scalar Value)。它的大小通常是 32 位（以容纳所有 Unicode 标量值），但具体实现可能有所不同。用于表示单个字符。</li>
</ul>
<h3 id="5-void-类型-unit-type"><a class="header" href="#5-void-类型-unit-type">5. <code>void</code> 类型 (Unit Type)</a></h3>
<ul>
<li><code>void</code>: 这个类型只有一个值（即unit <code>()</code>）。它用于表示函数不返回任何有意义的值，或者用于泛型编程中表示空占位符。</li>
</ul>
<h3 id="6-指针类型-pointer-types"><a class="header" href="#6-指针类型-pointer-types">6. 指针类型 (Pointer Types)</a></h3>
<p>Flurry 提供了对指针的底层访问能力（尤其在 <code>unsafe</code> 上下文中），预计包含：</p>
<ul>
<li><code>*T</code>: 指向类型 <code>T</code> 的<strong>不可变</strong>原始指针 (Raw Pointer)。</li>
</ul>
<p>原始指针的操作（解引用、算术）通常被认为是 <code>unsafe</code> 的，因为编译器不保证它们指向有效的内存或没有别名冲突。Flurry 的可达性类型系统和副作用系统旨在配合这些指针类型，提供比 C/C++ 更强的（即使在 <code>unsafe</code> 中）分析和潜在保证。</p>
<h3 id="7-编译时特定类型-compile-time-specific-types"><a class="header" href="#7-编译时特定类型-compile-time-specific-types">7. 编译时特定类型 (Compile-time Specific Types)</a></h3>
<p>Flurry 的 <code>comptime</code> 世界可能还包含一些特殊的编译时类型：</p>
<ul>
<li><strong><code>Type</code></strong>: 代表类型的类型。用于泛型、反射和编译时元编程。</li>
<li><strong><code>str</code> (编译时)</strong>: 字符串字面量的编译时类型，代表已知的文本内容。</li>
<li><strong><code>Symbol</code></strong>: 符号类型 (<code>.id</code>)，代表唯一的编译时标识符。</li>
<li><strong><code>Integer</code>, <code>Real</code> (编译时)</strong>: 未指定大小的、数学意义上的整数和实数类型，可能在字面量推断或 <code>comptime</code> 计算的中间阶段使用，最终会“沉降”为具体的运行时类型。</li>
</ul>
<h3 id="类型推断与注解"><a class="header" href="#类型推断与注解">类型推断与注解</a></h3>
<p>Flurry 通常支持类型推断，允许在 <code>let</code> 绑定等地方省略类型注解，编译器会根据初始化表达式推断类型。但在函数签名、结构体字段等地方，通常需要显式类型注解。</p>
<pre><code class="language-flurry">let implicit_int = 42; -- 推断为 i32 (或默认整数类型)
let explicit_float: f64 = 3.14;
</code></pre>
<p>理解这些基本类型及其特征是构建任何 Flurry 程序的基础。它们提供了操作数据和表达计算所需的基本构件。</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="符号"><a class="header" href="#符号">符号</a></h1>
<h2 id="符号-symbols"><a class="header" href="#符号-symbols">符号 (Symbols)</a></h2>
<p>符号 (Symbol) 是 Flurry 语言中一种独特的<strong>编译时常量类型</strong>，它提供了一种表示<strong>唯一标识符</strong>的轻量级方式。符号在 Flurry 的元编程、属性系统以及某些 DSL 构建场景中扮演着重要角色。</p>
<h3 id="语法"><a class="header" href="#语法">语法</a></h3>
<p>符号字面量以一个点 <code>.</code> 开始，后跟一个合法的 Flurry 标识符：</p>
<pre><code class="language-flurry">.ok
.error
.pending
.my_custom_identifier
.color
.width
</code></pre>
<h3 id="特性"><a class="header" href="#特性">特性</a></h3>
<ol>
<li><strong>唯一性 (Uniqueness)</strong>: 在整个编译单元或特定上下文中（具体作用域规则待定），每个具有相同名称的符号字面量（例如 <code>.ok</code>）都代表<strong>同一个唯一的</strong>符号值。</li>
<li><strong>编译时常量 (Compile-time Constant)</strong>: 符号是<strong>编译时</strong>的概念。它们的值在编译期间完全确定。这意味着它们可以自由地用于 <code>comptime</code> 计算、模式匹配、以及作为编译时 <code>object</code> 的键。</li>
<li><strong>轻量级 (Lightweight)</strong>: 符号通常被实现为整数或指针大小的值，使得比较操作（判断两个符号是否相等）非常快速，通常只是一个简单的整数比较。</li>
<li><strong>非字符串 (Not Strings)</strong>: 尽管符号看起来像带前缀的标识符，但它们<strong>不是</strong>字符串。它们不直接支持字符串操作（如拼接、取子串）。它们的核心目的是作为唯一的原子标识符。可以通过取像操作 <code>symbol'tag_name</code> 来获取其对应的字符串表示（编译时常量字符串）。</li>
</ol>
<h3 id="用途"><a class="header" href="#用途">用途</a></h3>
<p>符号在 Flurry 中有多种重要用途：</p>
<ol>
<li>
<p><strong>枚举变体的简化表示 (Enum Variants)</strong>: 虽然 Flurry 的层级化枚举使用 <code>EnumName.Variant</code> 形式，但在模式匹配或某些上下文中，可以直接使用符号来匹配简单的、无数据的枚举变体（如果语法支持这种简写）。</p>
<pre><code class="language-flurry">-- 假设 Status 是 enum { ok, error, pending }
match current_status {
    .ok =&gt; println("Status is OK"), -- 使用符号匹配
    .error =&gt; handle_error(),
    .pending =&gt; wait_more(),
}
</code></pre>
<p><em>(注意：这种用法是否可行取决于 Flurry 模式匹配的具体规则。)</em></p>
</li>
<li>
<p><strong>编译时对象/映射的键 (Keys in Compile-time Objects/Maps)</strong>: 正如在 <code>comptime object</code> 中看到的，符号是其属性键的标准形式。</p>
<pre><code class="language-flurry">comptime let config = {
    .host "localhost",
    .port 8080,
    .log_level .debug -- 使用符号作为值
}
let level = config.get(.log_level, Symbol)?; -- 使用符号作为键
</code></pre>
</li>
<li>
<p><strong>属性系统的基础 (Foundation of Attribute System)</strong>: Flurry 的属性系统（无论是内部定义 <code>.attr value</code> 还是外部应用 <code>^attr term</code>）都依赖符号来标识属性的名称。<code>.packed</code>, <code>.no_mangle</code>, <code>.route</code> 等都是符号。</p>
</li>
<li>
<p><strong>轻量级标签/状态表示 (Lightweight Tags/State Representation)</strong>: 在需要表示一组固定、互斥的状态或标签，并且不需要携带额外数据时，符号提供了一种比字符串或完整枚举更轻量级的方式。</p>
</li>
<li>
<p><strong>元编程与反射 (Metaprogramming &amp; Reflection)</strong>: 在编译时操作类型信息时，字段名、方法名等可能被表示为符号。</p>
</li>
</ol>
<h3 id="与其他语言的比较"><a class="header" href="#与其他语言的比较">与其他语言的比较</a></h3>
<ul>
<li><strong>Ruby/Elixir Symbols/Atoms</strong>: Flurry 的符号与 Ruby 的 Symbol (<code>:symbol</code>) 和 Elixir 的 Atom (<code>:atom</code>) 非常相似，都用作轻量级、唯一的标识符常量。</li>
<li><strong>Julia Symbols</strong>: Julia 也有类似的 <code>Symbol</code> 类型 (<code>:symbol</code>)。</li>
<li><strong>Lisp Symbols</strong>: Lisp 中的符号功能更强大，既是标识符也是数据，但 Flurry 的符号似乎更侧重于作为编译时常量标识符。</li>
</ul>
<h3 id="总结"><a class="header" href="#总结">总结</a></h3>
<p>符号是 Flurry 编译时系统中的一个重要构件。通过提供一种轻量级、唯一且编译时确定的标识符表示，符号简化了元编程、属性访问和某些模式匹配场景，并与 Flurry 的 <code>comptime object</code> 和属性系统紧密集成。理解符号的概念对于深入利用 Flurry 的编译时能力和编写惯用的 Flurry 代码非常重要。</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="第-4-章变量所有权与资源管理"><a class="header" href="#第-4-章变量所有权与资源管理">第 4 章：变量、所有权与资源管理</a></h1>
<p>Flurry 作为一门系统级编程语言，对资源的精确控制和内存安全给予了高度重视。与传统的 C/C++ 手动管理内存不同，也与纯粹的垃圾回收机制不同，Flurry 采用了一套结合了<strong>所有权 (Ownership)</strong>、<strong>仿射类型 (Affine Types)</strong> 和<strong>自动资源管理</strong>的机制，并辅以独特的<strong>可达性分析</strong>与<strong>副作用系统</strong>来确保安全性和效率。</p>
<p>本章将深入探讨 Flurry 如何管理变量的生命周期、数据的所有权以及相关资源的释放。理解这些核心概念对于编写安全、高效且无内存泄漏的 Flurry 代码至关重要。</p>
<p><strong>核心概念:</strong></p>
<ul>
<li><strong>变量绑定</strong>: 如何在 Flurry 中声明变量和常量。</li>
<li><strong>所有权</strong>: 每个值在 Flurry 中都有一个明确的“所有者”。所有权决定了谁负责清理资源。</li>
<li><strong>移动语义</strong>: 对于非 <code>Copy</code> 类型，所有权如何在变量绑定、函数调用和返回时发生转移。</li>
<li><strong>仿射类型</strong>: 非 <code>Copy</code> 类型的值默认遵循“至多使用一次”的规则，这是确保资源安全的关键。</li>
<li><strong>引用</strong>: 如何在不转移所有权的情况下安全地访问数据。</li>
<li><strong>自动资源管理 (<code>drop</code>)</strong>: 编译器如何自动管理资源的释放（如内存、文件句柄等）。</li>
<li><strong>安全保证机制</strong>: 概述 Flurry 如何通过类型系统、可达性分析和副作用跟踪来保证内存安全（特别是引用的有效性）。</li>
</ul>
<p><strong>章节内容:</strong></p>
<ul>
<li><strong><a href="core/core/ownership/bindings.html">声明与绑定</a></strong>: 介绍 <code>let</code> 和 <code>const</code> 如何用于创建变量和常量绑定，并讨论 Flurry 在可变性方面的设计选择。</li>
<li><strong><a href="core/core/ownership/affine_move.html">仿射类型与移动语义</a></strong>: 详细解释 <code>Once</code>, <code>Clone</code>, <code>Copy</code> Trait 层次，以及非 <code>Copy</code> 类型的所有权转移规则。</li>
<li><strong><a href="core/core/ownership/references.html">引用与借用</a></strong>: 探讨指针 (<code>*</code>) 和切片 (<code>Slice</code>) 等引用类型的作用，以及 Flurry 特色的后缀引用 (<code>.ref</code>) 和解引用 (<code>.*</code>) 语法。</li>
<li><strong><a href="core/core/ownership/drop.html">资源管理与 Drop</a></strong>: 阐述 Flurry 的 RAII 原则和编译器自动插入 <code>drop</code> 调用的机制。</li>
<li><strong><a href="core/core/ownership/reachability_effects.html">引用有效性：可达性与副作用</a></strong>: 简要介绍 Flurry 用于保证引用有效性的高级机制的目标和作用（为后续深入探讨做铺垫）。</li>
</ul>
<p>掌握 Flurry 的所有权和资源管理系统是编写健壮系统级代码的基础。它旨在提供 C/C++ 级别的控制力和性能，同时具备现代语言的内存安全保证。</p>
<div style="break-before: page; page-break-before: always;"></div><h2 id="声明与绑定"><a class="header" href="#声明与绑定">声明与绑定</a></h2>
<p>在 Flurry 中，我们将值与名称相关联的过程称为<strong>绑定 (Binding)</strong>。通过绑定，我们可以方便地引用和操作数据。Flurry 提供了两种主要的绑定方式：<code>let</code> 用于变量绑定，<code>const</code> 用于常量绑定。</p>
<h3 id="变量绑定-let"><a class="header" href="#变量绑定-let">变量绑定 (<code>let</code>)</a></h3>
<p>使用 <code>let</code> 关键字可以创建一个变量绑定。</p>
<pre><code class="language-flurry">let message = "Hello, Flurry!";
let count = 0;
let pi: f64 = 3.14159; -- 显式类型注解
</code></pre>
<ul>
<li><strong>类型推断</strong>: Flurry 通常支持类型推断。如果初始化表达式的类型可以明确推断出来，你可以省略类型注解（如 <code>message</code> 和 <code>count</code>）。</li>
<li><strong>显式注解</strong>: 你也可以使用 <code>:</code> 后跟类型来显式指定变量的类型（如 <code>pi</code>）。在函数签名、结构体字段等需要明确类型的地方，类型注解通常是必需的。</li>
</ul>
<p><strong>可变性 (Mutability)</strong>:</p>
<p>与某些强制区分可变与不可变绑定的语言（如 Rust 的 <code>let</code> vs <code>let</code>）不同，Flurry（类似于 Zig 的设计思路）在 <code>let</code> 绑定层面<strong>可能不严格强制区分可变性</strong>。这意味着通过 <code>let</code> 绑定的变量<strong>默认可能是可变的</strong>。</p>
<pre><code class="language-flurry">let counter = 0;
counter = counter + 1; -- 假设 let 默认允许修改

-- 如果需要强制不可变绑定，语言可能有其他机制，
-- 或者依赖于后续的使用方式分析（例如，传递不可变引用）。
-- 目前我们假设 let 绑定允许后续赋值。
</code></pre>
<p><em>TODO: 明确 Flurry <code>let</code> 的确切可变性语义。是默认可变，还是有单独的 <code>var</code> 关键字，或者通过其他方式控制？当前暂按“默认可变”或“不强制区分”处理。</em></p>
<p>这种设计选择旨在简化变量声明，将可变性控制的重心更多地放在类型系统（例如，可变引用 <code>*mut T</code> vs. 不可变引用 <code>*T</code>）和副作用分析上。</p>
<h3 id="常量绑定-const"><a class="header" href="#常量绑定-const">常量绑定 (<code>const</code>)</a></h3>
<p>使用 <code>const</code> 关键字可以创建一个常量绑定。常量与变量的关键区别在于：</p>
<ol>
<li><strong>编译时求值</strong>: <code>const</code> 绑定的值<strong>必须在编译时就能完全确定</strong>。初始化表达式必须是一个编译时常量表达式。</li>
<li><strong>完全不可变</strong>: 常量的值在程序运行期间不能被改变。它们通常会被编译器直接内联或放入只读内存段。</li>
<li><strong>类型注解通常需要</strong>: 常量的类型通常需要显式注解，因为编译器不会像对 <code>let</code> 那样进行复杂的类型推断（尽管简单的字面量类型可能可以推断）。</li>
</ol>
<pre><code class="language-flurry">const MAX_USERS: usize = 1000;
const DEFAULT_TIMEOUT: Duration = Duration.seconds(5); -- 假设 Duration.seconds 是 comptime 函数
const APP_NAME: str = "Flurry Core System"; -- 编译时字符串

-- const RUNTIME_VALUE: i32 = get_runtime_input(); -- 非法，初始化器不是编译时常量
</code></pre>
<p>常量非常适合用于定义程序中不变的配置值、标志、或者需要在编译时进行计算和使用的值。它们是 Flurry 强大的 <code>comptime</code> 能力的基础体现之一。</p>
<h3 id="作用域与遮蔽-scope--shadowing"><a class="header" href="#作用域与遮蔽-scope--shadowing">作用域与遮蔽 (Scope &amp; Shadowing)</a></h3>
<p>Flurry 中的绑定遵循词法作用域规则。一个绑定只在其声明的代码块（及其子块）内有效。</p>
<pre><code class="language-flurry">fn main() {
    let x = 10;
    { -- 进入新的作用域
        let y = 20;
        println("Inner: x = {i32}, y = {i32}", x, y); -- x 和 y 都可见
        let x = 5; -- 在内层作用域 "遮蔽" 外层的 x
        println("Inner (shadowed): x = {i32}", x); -- 输出 5
    } -- y 在此离开作用域
    -- println("Outer: y = {}", y); -- 错误，y 不在此作用域
    println("Outer: x = {i32}", x); -- 输出 10，内层的 x 遮蔽结束
}
</code></pre>
<p>Flurry 允许在内部作用域使用 <code>let</code> 重新声明一个同名变量，这会<strong>遮蔽 (Shadow)</strong> 外部作用域的同名变量。被遮蔽的变量在内部作用域内暂时不可访问，直到内部作用域结束。遮蔽是一个有用的特性，例如用于类型转换或值的重新绑定，但过度使用可能会降低代码清晰度。</p>
<p>理解 <code>let</code> 和 <code>const</code> 的区别以及作用域规则，是管理程序状态和数据生命周期的基础。</p>
<div style="break-before: page; page-break-before: always;"></div><h2 id="仿射类型与移动语义"><a class="header" href="#仿射类型与移动语义">仿射类型与移动语义</a></h2>
<p>Flurry 的核心安全策略之一是其对资源所有权的管理。它借鉴并发展了仿射类型系统 (Affine Type System) 的思想，规定了值的“使用次数”，并以此为基础实现了<strong>移动语义 (Move Semantics)</strong>，从而在没有传统垃圾回收器的情况下自动管理资源（如内存、文件句柄等）的生命周期。</p>
<h3 id="once-clone-copy-类型能力层次"><a class="header" href="#once-clone-copy-类型能力层次"><code>Once</code>, <code>Clone</code>, <code>Copy</code>: 类型能力层次</a></h3>
<p>在 Flurry 中，所有类型都隐式地属于一个能力层次，决定了它们的值可以如何被使用和复制：</p>
<ol>
<li>
<p><strong><code>Once</code> Trait (基础能力)</strong>:</p>
<ul>
<li><strong>所有类型</strong>都自动具备 <code>Once</code> 能力。这从概念上标记了一个值<strong>可以被销毁或最终使用一次</strong>。它更像是一个逻辑基础，表明每个值都有其生命周期的终点。对于实际编程而言，更重要的是 <code>Copy</code> 和 <code>Clone</code> 的缺失或存在。</li>
</ul>
</li>
<li>
<p><strong><code>Clone</code> Trait (可克隆)</strong>:</p>
<ul>
<li>如果一个类型需要能够创建其值的<strong>深拷贝 (Deep Copy)</strong>（即创建一个完全独立的、拥有自己资源的新副本），它可以实现 <code>Clone</code> Trait。</li>
<li>实现 <code>Clone</code> 通常需要显式地编写 <code>.clone()</code> 方法来定义克隆逻辑。</li>
<li><code>Clone</code> 的实例可以被多次使用——通过显式调用 <code>.clone()</code> 来创建新的所有权实例。</li>
</ul>
</li>
<li>
<p><strong><code>Copy</code> Trait (可按位复制)</strong>:</p>
<ul>
<li><code>Copy</code> 是 <code>Clone</code> 的一个特殊子集。如果一个类型的克隆操作仅仅是<strong>简单的按位复制 (Bitwise Copy)</strong>，并且复制后原始值仍然有效（即类型不拥有需要特殊释放的资源，如堆内存指针、文件句柄），那么它可以实现 <code>Copy</code> Trait。</li>
<li><strong>常见 <code>Copy</code> 类型</strong>: 包括基本类型（如整数 <code>i32</code>, 浮点数 <code>f64</code>, 布尔 <code>bool</code>, 字符 <code>char</code>）、只包含 <code>Copy</code> 类型字段的结构体或元组，以及某些引用类型（如 <code>*T</code>，指针本身的复制是按位复制，但不复制指向的数据）。</li>
<li><strong>隐式复制</strong>: <code>Copy</code> 类型的值在赋值、函数参数传递（按值）或函数返回时，会<strong>自动进行按位复制</strong>。原始值和新副本都是有效的、独立的值。</li>
<li><strong>无需实现 <code>Clone</code></strong>: 实现了 <code>Copy</code> 的类型通常不再需要手动实现 <code>Clone</code>，因为简单的位复制就是其克隆方式（编译器可能会自动提供）。</li>
</ul>
</li>
</ol>
<h3 id="移动语义-move-semantics"><a class="header" href="#移动语义-move-semantics">移动语义 (Move Semantics)</a></h3>
<p><strong>核心规则</strong>: 对于<strong>没有</strong>实现 <code>Copy</code> Trait 的类型（通常称为“移动类型”或“非 <code>Copy</code> 类型”），当它们的值被用在所有权转移的场景时，所有权会从源“移动”到目标，源将<strong>不再有效</strong>。</p>
<p><strong>所有权转移场景</strong>:</p>
<ol>
<li>
<p><strong>赋值 (<code>let new_owner = old_owner;</code>)</strong>:</p>
<pre><code class="language-flurry">let s1 = String.from("hello"); -- String 通常不是 Copy 类型
let s2 = s1; -- s1 的所有权移动到 s2
-- println(s1); -- 编译错误！s1 不再拥有值，其绑定失效
println(s2); -- OK
</code></pre>
</li>
<li>
<p><strong>函数参数传递 (按值)</strong>:</p>
<pre><code class="language-flurry">fn takes_ownership(some_string: String) {
    println(some_string);
} -- some_string 在这里离开作用域，其拥有的资源被 drop

let message = String.from("world");
takes_ownership(message); -- message 的所有权移动到函数参数 some_string
-- println(message); -- 编译错误！message 不再有效
</code></pre>
</li>
<li>
<p><strong>函数返回值</strong>:</p>
<pre><code class="language-flurry">fn creates_string() -&gt; String {
    let s = String.from("new string");
    s -- 返回 s，所有权从 s 移动到函数调用者
}

let my_string = creates_string(); -- my_string 接收了函数返回的 String 的所有权
println(my_string); -- OK
</code></pre>
</li>
</ol>
<p><strong>仿射类型：“至多使用一次”</strong></p>
<p>移动语义是仿射类型系统规则的直接体现：一个非 <code>Copy</code> 的值，其所有权在任意时刻只能存在于一个地方。一旦所有权转移（被“移动”），原来的绑定就不能再被用来访问这个值了。你可以认为这个值被“消耗”了。</p>
<p><strong>为什么需要移动语义/仿射类型？</strong></p>
<ul>
<li><strong>资源安全</strong>: 这是 Flurry 自动管理资源的关键。对于持有堆内存、文件句柄、网络连接等资源的值，移动语义确保了<strong>只有一个所有者</strong>负责在适当的时候释放这些资源（通常通过 <code>drop</code> 机制）。它从根本上防止了<strong>二次释放 (Double Free)</strong> 错误。</li>
<li><strong>数据竞争预防 (基础)</strong>: 虽然完整的线程安全还需要其他机制，但所有权转移有助于防止多个线程同时持有对同一份可变数据（非 <code>Copy</code> 类型通常是可变的或包含可变部分）的写入权限。</li>
<li><strong>性能</strong>: 避免了不必要的深拷贝。对于大型数据结构，移动通常比克隆高效得多（通常只是栈上指针或元数据的复制）。</li>
</ul>
<p><strong>总结</strong>:</p>
<p>Flurry 通过 <code>Copy</code> Trait 区分了可以廉价、安全地进行按位复制的值和那些拥有独特资源所有权的值。对于后者（非 <code>Copy</code> 类型），Flurry 强制实行<strong>移动语义</strong>，确保资源所有权的唯一性，这是其内存安全和自动资源管理策略的基础。理解值是 <code>Copy</code> 还是 Move（非 <code>Copy</code>）对于预测代码行为和避免所有权相关的编译错误至关重要。</p>
<div style="break-before: page; page-break-before: always;"></div><h2 id="引用与借用"><a class="header" href="#引用与借用">引用与“借用”</a></h2>
<p>Flurry 的所有权系统确保了每个值都有一个唯一的所有者，这对于资源管理至关重要。然而，在实际编程中，我们经常需要在不转移所有权的情况下<strong>访问</strong>或<strong>使用</strong>数据。例如，我们可能想让多个函数读取同一个配置对象，或者将一个大数据结构的片段传递给一个处理函数。为了满足这些需求，Flurry 提供了<strong>引用 (References)</strong>。</p>
<p>与所有权直接控制值本身不同，引用允许我们创建一个指向值的<strong>间接访问途径</strong>。在 Flurry 中，主要的引用类型是指针 (<code>*T</code>) 和切片 (<code>Slice&lt;T&gt;</code>)。</p>
<h3 id="指针-t"><a class="header" href="#指针-t">指针 (<code>*T</code>)</a></h3>
<p>指针是内存地址的直接表示，它“指向”内存中某个特定类型 <code>T</code> 的值所在的位置。</p>
<ul>
<li><strong>类型</strong>: <code>*T</code> 表示一个指向类型 <code>T</code> 的值的指针。Flurry <strong>不</strong>在类型层面显式区分可变与不可变指针（即没有类似 Rust 的 <code>&amp;T</code> vs <code>&amp;mut T</code>）。一个 <code>*T</code> 是否允许修改其指向的数据，可能取决于指针的来源、上下文（如函数参数是否允许修改）或是否在 <code>unsafe</code> 块内。<em>（TODO: 明确指针的可变性规则和保证机制）</em></li>
<li><strong>获取指针</strong>: 可以使用后缀 <code>.ref</code> 操作符来获取一个值的指针。
<pre><code class="language-flurry">let data = MyData { ... }
let data_ptr: *MyData = data.ref; -- 获取 data 的指针
</code></pre>
</li>
<li><strong>解引用</strong>: 可以使用后缀 <code>.*</code> 操作符来访问指针指向的值。
<pre><code class="language-flurry">let value_copy = data_ptr.*; -- 解引用，获取 data 的一个副本（如果 MyData 是 Copy）
                           -- 或者可能获取对 data 内部字段的访问权
-- (解引用的具体语义，特别是对于非 Copy 类型，需要进一步明确)

-- 访问字段或调用方法通常通过指针自动解引用（如果语言支持）或显式解引用
-- println(data_ptr.some_field);  -- 类似 C/Zig 的隐式解引用？
-- println((data_ptr.*).some_field); -- 或者需要显式解引用？
-- data_ptr.some_method();       -- 方法调用是否自动解引用？
</code></pre>
<em>TODO: 明确指针访问成员和调用方法的具体语法和解引用规则。</em></li>
<li><strong>安全性</strong>: 直接操作原始指针（进行算术运算、类型转换等）通常被认为是 <code>unsafe</code> 操作。然而，Flurry 的目标是利用其<strong>可达性类型系统</strong>和<strong>副作用系统</strong>来保证即使是传递和使用指针（由 <code>.ref</code> 创建，并在 <code>safe</code> 代码中传递）也是安全的，主要是防止悬垂指针（即指针指向的内存不再有效或已被释放）。</li>
</ul>
<h3 id="切片-slicet"><a class="header" href="#切片-slicet">切片 (<code>Slice&lt;T&gt;</code>)</a></h3>
<p>切片提供了一种指向内存中<strong>连续序列</strong>（如数组、向量或字符串的一部分）的视图。切片本身通常不拥有数据，而是“借用”了底层数据的一部分。</p>
<ul>
<li><strong>类型</strong>: <code>Slice&lt;T&gt;</code> 表示一个包含 <code>T</code> 类型元素的连续序列的引用。</li>
<li><strong>构成</strong>: 一个切片通常包含两部分信息：一个指向序列起始元素的指针，以及序列的长度。</li>
<li><strong>创建</strong>: 可以从数组、向量或其他支持切片操作的数据结构创建切片。
<pre><code class="language-flurry">let array = [1, 2, 3, 4, 5];
let full_slice: Slice&lt;i32&gt; = array.slice(..); -- 获取整个数组的切片
let partial_slice = array.slice(1..4); -- 获取索引 1 到 3 (不含 4) 的切片
</code></pre>
<em>TODO: 确认切片创建的具体语法。</em></li>
<li><strong>用途</strong>: 切片非常适合用于处理数据缓冲区、字符串视图等，它允许函数操作数据的子集而无需复制或转移整个数据结构的所有权。</li>
<li><strong>安全性</strong>: 与指针类似，切片的有效性（确保它指向的底层数据在切片存续期间保持有效）也依赖于 Flurry 的可达性类型系统和副作用系统的保证。</li>
</ul>
<h3 id="借用-的概念"><a class="header" href="#借用-的概念">"借用" 的概念</a></h3>
<p>虽然 Flurry 可能没有像 Rust 那样严格且形式化的“借用检查器 (Borrow Checker)”术语和规则集，但<strong>引用的核心目的</strong>仍然是实现<strong>临时、非拥有式的数据访问</strong>，这在概念上就是一种**“借用”**。</p>
<ul>
<li><strong>不转移所有权</strong>: 当你通过 <code>.ref</code> 获取指针或创建切片时，原始数据的所有权<strong>不会</strong>发生转移。原始所有者仍然负责数据的生命周期和最终的清理。</li>
<li><strong>生命周期依赖</strong>: 引用的有效性<strong>依赖于</strong>其指向的数据的生命周期。引用不能比它所指向的数据活得更长。这是 Flurry 的可达性分析和副作用系统需要强制执行的关键保证。</li>
</ul>
<p><strong>示例对比:</strong></p>
<pre><code class="language-flurry">fn consume_data(data: MyData) { -- 接受所有权
    -- data 在此被消耗或在函数结束时 drop
}

fn use_data_ref(data_ref: *MyData) { -- "借用" 数据
    -- 通过 data_ref 访问数据，但不拥有它
    let field_value = data_ref.*.some_field; -- 假设需要显式解引用
    -- ...
} -- data_ref 指针本身离开作用域，但不影响原始 data

fn main() {
    let my_data = MyData { ... }

    let data_ptr = my_data.ref; -- 创建引用（借用）
    use_data_ref(data_ptr);    -- 传递引用
    use_data_ref(my_data.ref); -- 再次创建并传递引用 (OK)

    consume_data(my_data);    -- 转移所有权
    -- use_data_ref(data_ptr);    -- 编译错误！data_ptr 现在是悬垂指针，指向的数据已被移动
                               -- (Flurry 的安全系统需要能捕捉到这个)
}
</code></pre>
<h3 id="总结-1"><a class="header" href="#总结-1">总结</a></h3>
<p>引用（指针和切片）是 Flurry 中实现数据共享和非拥有式访问的关键机制。通过 <code>.ref</code> 获取指针，通过切片语法获取序列视图，可以在不干扰所有权的情况下传递和使用数据。Flurry 不依赖显式的 <code>mut</code> 区分可变/不可变引用类型，而是计划通过其独特的<strong>可达性类型系统</strong>和<strong>副作用系统</strong>来保证引用的有效性（防止悬垂引用），从而在提供灵活性的同时确保内存安全。理解引用的“借用”本质及其与所有权的区别，对于编写正确的 Flurry 程序至关重要。</p>
<div style="break-before: page; page-break-before: always;"></div><h2 id="资源管理与-drop-精化"><a class="header" href="#资源管理与-drop-精化">资源管理与 Drop 精化</a></h2>
<p>Flurry 的所有权系统不仅仅是为了防止数据竞争或非法访问，其核心目标之一是实现<strong>可靠且自动的资源管理</strong>。无论是堆上分配的内存、打开的文件句柄、网络套接字还是其他系统资源，都需要在不再使用时被精确地释放，以避免泄漏。Flurry 通过类似于 C++ RAII (Resource Acquisition Is Initialization) 和 Rust <code>Drop</code> Trait 的机制，结合编译器的<strong>Drop 精化 (Drop Elaboration)</strong> 来自动化这个过程。</p>
<h3 id="raii-资源生命周期绑定到对象生命周期"><a class="header" href="#raii-资源生命周期绑定到对象生命周期">RAII: 资源生命周期绑定到对象生命周期</a></h3>
<p>Flurry 遵循 RAII 的核心思想：资源的生命周期与拥有该资源的对象（值）的生命周期相绑定。</p>
<ol>
<li><strong>获取即初始化</strong>: 当创建一个需要管理资源的对象时（例如，调用 <code>File.open(...)</code> 或 <code>Vec.new()</code>），该对象在其内部获取并管理所需的资源（文件句柄、堆内存）。</li>
<li><strong>析构即释放</strong>: 当该对象<strong>离开其作用域</strong>或者其<strong>所有权结束</strong>时，它所拥有的资源必须被释放。</li>
</ol>
<h3 id="drop-操作与-drop-trait-假设"><a class="header" href="#drop-操作与-drop-trait-假设"><code>drop</code> 操作与 <code>Drop</code> Trait (假设)</a></h3>
<p>为了实现资源的自动释放，Flurry 预计会提供一个类似 Rust <code>Drop</code> Trait 的机制（具体名称和形式待定，我们暂且称之为 <code>Drop</code>）：</p>
<ul>
<li><strong><code>Drop</code> Trait</strong>: 需要自定义资源清理逻辑的类型可以实现 <code>Drop</code> Trait。这个 Trait 通常包含一个 <code>drop</code> 方法。
<pre><code class="language-flurry">-- 概念性示例
trait Drop {
    fn drop(*self); -- drop 方法接收一个可变指针
}

impl Drop for MyFileWrapper {
    fn drop(*self) {
        -- 关闭文件句柄，释放相关资源
        unsafe { close_file_handle(self.handle) }
        println("MyFileWrapper dropped!");
    }
}
</code></pre>
</li>
<li><strong>默认行为</strong>: 对于没有实现 <code>Drop</code> Trait 的类型（例如只包含 <code>Copy</code> 类型字段的结构体），其“drop”操作通常是无操作 (no-op)，或者仅仅是递归地 drop 其包含的字段（如果字段本身实现了 <code>Drop</code>）。</li>
</ul>
<h3 id="编译器的-drop-精化"><a class="header" href="#编译器的-drop-精化">编译器的 Drop 精化</a></h3>
<p>开发者通常<strong>不需要手动调用</strong> <code>drop</code> 方法。Flurry 编译器的关键职责之一就是执行 <strong>Drop 精化</strong>：在编译期间，静态地分析代码，并在每个值的所有权结束时<strong>自动插入对 <code>drop</code> 的调用</strong>。</p>
<p><strong>编译器插入 <code>drop</code> 的时机:</strong></p>
<p>编译器通过<strong>所有权</strong>和<strong>生命周期</strong>分析来确定何时插入 <code>drop</code>：</p>
<ol>
<li>
<p><strong>离开作用域</strong>: 当一个拥有资源的值（非 <code>Copy</code> 类型）绑定的变量离开其声明的作用域时，并且其所有权没有被移动走，编译器会在此作用域结束处插入 <code>drop</code> 调用。</p>
<pre><code class="language-flurry">{
    let file = File.open("temp.txt")!; -- file 拥有文件句柄
    -- ... 使用 file ...
} -- file 离开作用域，编译器在此处隐式插入 drop(file)
</code></pre>
</li>
<li>
<p><strong>所有权转移后</strong>: 如果一个值的所有权被移动（例如，赋值给新变量、作为函数参数传递、从函数返回），则<strong>原来的绑定</strong>就不再拥有该值，编译器<strong>不会</strong>在其离开作用域时为其插入 <code>drop</code>。<code>drop</code> 的责任随着所有权一起转移给了新的所有者。</p>
<pre><code class="language-flurry">fn process_file(f: File) {
    -- ... f 在函数内部被使用 ...
} -- f 在函数结束时离开作用域，编译器在此处插入 drop(f)

let my_file = File.open("data.log")!;
process_file(my_file); -- 所有权移动到 f
-- my_file 离开作用域，但所有权已转移，编译器 *不* 在此处为 my_file 插入 drop
</code></pre>
</li>
<li>
<p><strong>控制流</strong>: 编译器需要分析 <code>if</code>/<code>else</code>、<code>match</code>、循环等控制流。如果一个值在某个代码分支中被移动或消耗，而在另一个分支中没有，编译器需要确保在后者对应的路径结束时插入 <code>drop</code>。</p>
<pre><code class="language-flurry">fn example(use_it: bool) {
    let data = allocate_resource();
    if use_it {
        consume_resource(data); -- data 所有权在这里被转移
    } else {
        -- data 在这个分支没有被消耗
        println("Resource not consumed.");
    }
    -- 编译器需要分析：
    -- 如果 use_it 为 true，data 已被移动，这里什么都不做。
    -- 如果 use_it 为 false，data 仍然有效且即将离开作用域，
    -- 编译器会在此处（概念上是 else 分支结束和函数返回之间）插入 drop(data)。
}
</code></pre>
<p>这与您在问题描述中给出的 <code>main</code> 和 <code>consumes</code> 函数示例的行为一致。</p>
</li>
</ol>
<p><strong>优势:</strong></p>
<ul>
<li><strong>自动化</strong>: 开发者无需手动管理资源释放，减少了忘记释放资源导致泄漏的可能性。</li>
<li><strong>及时性</strong>: 资源在不再需要时（所有权结束时）立即被释放，而不是等待垃圾回收器运行，这对于需要精确控制生命周期的资源（如文件锁、网络连接）非常重要。</li>
<li><strong>确定性</strong>: 资源释放的时机是确定的（由作用域和所有权规则决定），便于推理程序的行为。</li>
<li><strong>异常安全 (潜力)</strong>: 如果与错误处理（例如 <code>!</code>）或效应系统（如代数效应）结合，可以设计出即使在发生错误或非本地控制流转移时也能保证资源被正确释放的模式（例如，通过 unwind 或者特定的恢复机制调用 <code>drop</code>）。</li>
</ul>
<p><strong>总结:</strong></p>
<p>Flurry 通过结合 RAII 原则、类似 <code>Drop</code> Trait 的机制以及编译器的<strong>Drop 精化</strong>，实现了自动化、确定性的资源管理。编译器静态地跟踪值的所有权和生命周期，在所有权结束时自动插入资源释放逻辑 (<code>drop</code>)。这使得开发者能够专注于业务逻辑，同时获得强大的内存安全和资源安全保证，避免了手动资源管理带来的许多常见错误。理解 Drop 精化是理解 Flurry 如何确保资源安全的关键。</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="引用有效性可达性与副作用"><a class="header" href="#引用有效性可达性与副作用">引用有效性：可达性与副作用</a></h1>
<div style="break-before: page; page-break-before: always;"></div><h1 id="第-5-章表达式与运算符"><a class="header" href="#第-5-章表达式与运算符">第 5 章：表达式与运算符</a></h1>
<p>表达式 (Expressions) 是 Flurry 程序中计算值的基本方式。它们由字面量、变量、常量、运算符和函数调用等组合而成。Flurry 的表达式系统设计旨在提供强大的表达能力，同时通过一致的语法风格（特别是后缀操作）提升代码的可读性和流畅性。</p>
<p>本章将深入探讨 Flurry 中各种表达式的构成、运算符的行为与优先级，以及 Flurry 独特的“取像”操作。</p>
<p><strong>核心概念:</strong></p>
<ul>
<li><strong>表达式求值</strong>: 任何表达式最终都会计算出一个值（除非它发散或产生副作用）。</li>
<li><strong>运算符</strong>: 用于组合或修改值的特殊符号（如 <code>+</code>, <code>-</code>, <code>&gt;</code>, <code>.</code>）。</li>
<li><strong>优先级与结合性</strong>: 决定复杂表达式中运算符的计算顺序。Flurry 采用 Pratt 解析器常用的绑定力 (Binding Power) 或优先级方案来处理。</li>
<li><strong>后缀风格</strong>: Flurry 大量采用后缀运算符和操作（如 <code>.field</code>, <code>.method()</code>, <code>.*</code>, <code>.ref</code>, <code>'image</code>），使得链式调用非常自然。</li>
<li><strong>无内置位运算符</strong>: Flurry 选择不提供传统的位运算符（<code>&amp;</code>, <code>|</code>, <code>^</code>, <code>~</code>, <code>&lt;&lt;</code>, <code>&gt;&gt;</code>），而是依赖 <code>bitvec</code> 抽象视图或标准库函数（如 <code>math</code> 包）进行位操作。</li>
<li><strong>编译时连接 (<code>++</code>)</strong>: <code>++</code> 运算符专用于编译时连接集合（如 <code>str</code>, <code>meta.List</code>）。</li>
</ul>
<p><strong>章节内容:</strong></p>
<ul>
<li><strong><a href="core/core/expressions/operators.html">常用运算符</a></strong>: 介绍 Flurry 支持的算术、比较、逻辑等运算符，并重点讨论它们的空格敏感性规则。</li>
<li><strong><a href="core/core/expressions/suffix_chaining.html">后缀风格与链式调用</a></strong>: 详细阐述选择运算符 (<code>.</code>)、解引用 (<code>.*</code>)、取引用 (<code>.ref</code>) 以及其他后缀操作如何促进流畅的链式调用。</li>
<li><strong><a href="core/core/expressions/image_op.html">取像操作 (expr ' image)</a></strong>: 深入讲解 <code>'</code> 操作符的用途，以及如何获取表达式的不同“像”。</li>
</ul>
<p>理解 Flurry 的表达式求值规则和运算符行为是编写任何非平凡程序的基础。其独特的后缀风格和对位运算的处理方式是需要特别注意的设计点。</p>
<div style="break-before: page; page-break-before: always;"></div><h2 id="常用运算符"><a class="header" href="#常用运算符">常用运算符</a></h2>
<p>运算符是 Flurry 语言中用于执行计算、比较、逻辑组合等操作的特殊符号。Flurry 提供了一组旨在清晰且富有表现力的运算符集合。</p>
<h3 id="算术运算符"><a class="header" href="#算术运算符">算术运算符</a></h3>
<p>用于执行基本的数学运算。这些运算符通常可以被用户定义的类型通过实现特定的 Trait 来重载。</p>
<ul>
<li><strong>加法 (<code>+</code>)</strong>: <code>a + b</code></li>
<li><strong>减法 (<code>-</code>)</strong>: <code>a - b</code></li>
<li><strong>乘法 (<code>*</code>)</strong>: <code>a * b</code></li>
<li><strong>除法 (<code>/</code>)</strong>: <code>a / b</code> (整数除法通常向零截断，浮点数除法遵循 IEEE 754)</li>
<li><strong>取模 (<code>%</code>)</strong>: <code>a % b</code> (计算除法的余数)</li>
</ul>
<p><strong>空格敏感性</strong>: 如词法结构中所述，这些二元算术运算符<strong>必须</strong>在其两侧使用空格，以便被词法分析器正确识别为标准算术运算符 token（例如 <code>_+_</code>）。<code>a+b</code> 不会被识别为标准的加法运算。</p>
<pre><code class="language-flurry">let sum = count + 1;
let difference = total - tax;
let area = width * height;
let quotient = dividend / divisor;
let remainder = value % modulus;
</code></pre>
<h3 id="比较运算符"><a class="header" href="#比较运算符">比较运算符</a></h3>
<p>用于比较两个值，结果通常是一个布尔值 (<code>bool</code>)。它们也可以被重载。</p>
<ul>
<li><strong>等于 (<code>==</code>)</strong>: <code>a == b</code></li>
<li><strong>不等于 (<code>!=</code>)</strong>: <code>a != b</code></li>
<li><strong>小于 (<code>&lt;</code>)</strong>: <code>a &lt; b</code></li>
<li><strong>小于等于 (<code>&lt;=</code>)</strong>: <code>a &lt;= b</code></li>
<li><strong>大于 (<code>&gt;</code>)</strong>: <code>a &gt; b</code></li>
<li><strong>大于等于 (<code>&gt;=</code>)</strong>: <code>a &gt;= b</code></li>
</ul>
<p><strong>空格敏感性</strong>: 小于 (<code>&lt;</code>) 和大于 (<code>&gt;</code>) 运算符同样具有<strong>空格敏感性</strong>。当用于比较时，它们两侧<strong>必须</strong>有空格（对应 <code>_&lt;_</code> 和 <code>_&gt;_</code> token）。这避免了与泛型参数列表等场景中使用的尖括号 (<code>&lt;</code>, <code>&gt;</code>) 产生词法歧义。</p>
<pre><code class="language-flurry">let is_equal = response_code == 200;
let is_not_empty = size != 0;
let in_range = value &gt;= min_value and value &lt;= max_value; -- 注意 'and' 关键字
let needs_update = current_version &lt; latest_version;
</code></pre>
<h3 id="逻辑运算符"><a class="header" href="#逻辑运算符">逻辑运算符</a></h3>
<p>用于组合布尔值。Flurry 使用关键字而非符号来表示逻辑与和或。</p>
<ul>
<li><strong>逻辑与 (<code>and</code>)</strong>: <code>a and b</code> (短路求值：如果 <code>a</code> 为 <code>false</code>，则不评估 <code>b</code>)</li>
<li><strong>逻辑或 (<code>or</code>)</strong>: <code>a or b</code> (短路求值：如果 <code>a</code> 为 <code>true</code>，则不评估 <code>b</code>)</li>
<li><strong>逻辑非 (<code>not</code>)</strong>: <code>not a</code> (一元运算符)</li>
</ul>
<pre><code class="language-flurry">let both_conditions_met = is_ready and has_permission;
let either_option_valid = is_primary or is_fallback;
let is_invalid = not is_valid;
</code></pre>
<h3 id="赋值运算符"><a class="header" href="#赋值运算符">赋值运算符</a></h3>
<p>用于将值赋给变量绑定。</p>
<ul>
<li><strong>简单赋值 (<code>=</code>)</strong>: <code>variable = value</code></li>
<li><strong>复合赋值</strong>:
<ul>
<li><code>+=</code>, <code>-=</code>, <code>*=</code>, <code>/=</code>, <code>%=</code> (例如 <code>a += b</code> 等价于 <code>a = a + b</code>)</li>
</ul>
</li>
</ul>
<pre><code class="language-flurry">let score = 0;
score += 10; -- score 现在是 10
</code></pre>
<p><em>注意：由于 Flurry 可能默认绑定是可变的，<code>let</code> 声明的 <code>score</code> 可以被复合赋值操作修改。</em></p>
<h3 id="其他重要操作符结构"><a class="header" href="#其他重要操作符结构">其他重要操作符/结构</a></h3>
<p>Flurry 还包含一些具有特殊语法和用途的操作符或结构，其中许多采用后缀形式（详见下一节）：</p>
<ul>
<li><strong>选择运算符 (<code>.</code>)</strong>: 用于访问成员、调用方法、限定路径等。</li>
<li><strong>解引用 (<code>.*</code>)</strong>: 后缀操作符，用于访问指针指向的值。</li>
<li><strong>取引用 (<code>.ref</code>)</strong>: 后缀操作符，用于获取一个值的指针。</li>
<li><strong>取像 (<code>'</code>)</strong>: 后缀操作符，用于 <code>expr ' image</code> 操作。</li>
<li><strong>调用操作符</strong>: <code>()</code> (函数调用), <code>[]</code> (索引调用), <code>{}</code> (<code>expr object</code> 调用/记录调用), <code>&lt;&gt;</code> (泛型/钻石调用)。</li>
<li><strong>错误/可选处理</strong>: <code>!</code> (错误传播/处理), <code>?</code> (可选类型处理)。</li>
<li><strong>效应处理</strong>: <code>#</code> (效应处理块)。</li>
<li><strong>属性标记 (<code>^</code>)</strong>: 用于附加属性。</li>
<li><strong>管道操作符 (<code>|</code>, <code>|&gt;</code>)</strong>: 用于函数式风格的数据流处理。</li>
</ul>
<h3 id="编译时连接运算符-"><a class="header" href="#编译时连接运算符-">编译时连接运算符 (<code>++</code>)</a></h3>
<ul>
<li><strong><code>++</code></strong>: 这个运算符<strong>专用于编译时</strong>，用于连接两个集合类的值。</li>
<li><strong>适用类型</strong>: 其具体行为取决于操作数类型所实现的特定 Trait（可重载）。常见的应用包括：
<ul>
<li>连接编译时字符串 (<code>str</code>)。</li>
<li>连接编译时列表 (<code>meta.List</code>)。</li>
<li>连接编译时集合 (<code>meta.Set</code>)。</li>
<li>连接 <code>bitvec</code> 抽象视图（编译器会将其优化为位操作）。</li>
</ul>
</li>
<li><strong>限制</strong>: <strong>不能</strong>直接用于运行时的值（除了 <code>bitvec</code> 抽象视图映射这种特殊情况，其本质也是编译时指导的优化）。</li>
</ul>
<pre><code class="language-flurry">comptime {
    const part1 = "Hello, ";
    const part2 = "Flurry!";
    const message = part1 ++ part2; -- message == "Hello, Flurry!"

    const list1 = meta.List.new(1, 2);
    const list2 = meta.List.new(3, 4);
    const combined_list = list1 ++ list2; -- combined_list == [1, 2, 3, 4]

    -- let runtime_vec1 = Vec.new();
    -- let runtime_vec2 = Vec.new();
    -- let result = runtime_vec1 ++ runtime_vec2; -- 编译错误！++ 不能用于运行时 Vec
}
</code></pre>
<h3 id="关于位运算符"><a class="header" href="#关于位运算符">关于位运算符</a></h3>
<p>值得再次强调，Flurry <strong>不提供</strong>内建的按位运算符（如 C/Java/Rust 中的 <code>&amp;</code>, <code>|</code>, <code>^</code>, <code>~</code>, <code>&lt;&lt;</code>, <code>&gt;&gt;</code>）。进行位级别的操作需要：</p>
<ol>
<li><strong>使用 <code>bitvec</code> 抽象视图</strong>: 通过取像操作 <code>value'bitvec</code> 获取值的位向量表示，然后对其进行连接 (<code>++</code>) 或其他位操作（这些操作会被编译器优化）。</li>
<li><strong>使用标准库函数</strong>: Flurry 计划提供一个内置的 <code>math</code>（或其他）包，其中包含执行位移、按位与/或/异或等操作的函数（例如 <code>math.bit_and(a, b)</code>）。</li>
</ol>
<p>这种设计选择旨在减少操作符集合的歧义，并将底层位操作封装在更明确的抽象（<code>bitvec</code>）或库函数中。</p>
<h3 id="运算符优先级与结合性"><a class="header" href="#运算符优先级与结合性">运算符优先级与结合性</a></h3>
<p>Flurry 使用 Pratt 解析器常用的<strong>绑定力 (Binding Power)</strong> 或等效的优先级方案来确定复杂表达式中运算符的计算顺序。您提供的 <code>OpTable</code> Scala 代码片段清晰地展示了不同 token 对应的优先级数值（数值越高，通常绑定得越紧密）。</p>
<p>例如，根据该表：</p>
<ul>
<li>乘法/除法/取模/<code>++</code> (<code>70</code>) 的优先级高于加法/减法 (<code>60</code>)。</li>
<li>加法/减法 (<code>60</code>) 的优先级高于比较运算符 (<code>40</code>)。</li>
<li>比较运算符 (<code>40</code>) 的优先级高于逻辑与 (<code>30</code>) 和逻辑或 (<code>20</code>)。</li>
<li>后缀操作符如选择 (<code>.</code>, 100)、取像 (<code>'</code>, 100)、调用 (<code>()</code>, <code>[]</code>, <code>{}</code>, <code>&lt;&gt;</code>, 90) 和可能的字面量拓展 (<code>id</code>, 110) 具有非常高的优先级。</li>
</ul>
<p>开发者通常不需要死记硬背完整的优先级表，而是遵循数学和逻辑运算的常规顺序，并在必要时使用圆括号 <code>()</code> 来明确指定求值顺序。</p>
<pre><code class="language-flurry">let result = a + b * c; -- 等价于 a + (b * c)，因为 * 优先级更高
let flag = x &gt; 0 and y &lt; 10; -- 等价于 (x &gt; 0) and (y &lt; 10)
let complex = (a + b) * (c - d); -- 使用括号强制优先级
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h2 id="后缀风格与链式调用"><a class="header" href="#后缀风格与链式调用">后缀风格与链式调用</a></h2>
<p>Flurry 语言在表达式语法设计上一个显著的特点是广泛采用<strong>后缀 (Suffix)</strong> 形式的操作符和语法结构。这种设计使得<strong>链式调用 (Method Chaining / Fluent Interface)</strong> 变得极其自然和流畅，提高了代码的可读性，使得代码逻辑能够从左到右平滑地展开。</p>
<p>核心的后缀操作符是<strong>选择运算符 (<code>.</code>)</strong>，但它的作用远不止访问字段。</p>
<h3 id="选择运算符--的多重角色"><a class="header" href="#选择运算符--的多重角色">选择运算符 (<code>.</code>) 的多重角色</a></h3>
<p>点号 <code>.</code> 是 Flurry 中最繁忙的操作符之一，它作为连接符，统一了多种常见的后缀操作：</p>
<ol>
<li>
<p><strong>访问结构体字段 (Field Access)</strong>:</p>
<pre><code class="language-flurry">struct Point { x: i32, y: i32 }
let p = Point { .x 10, .y 20 }
let x_coord = p.x; -- 访问字段 x
</code></pre>
</li>
<li>
<p><strong>调用方法 (Method Call)</strong>:</p>
<pre><code class="language-flurry">struct Greeter { name: String }
impl Greeter {
    fn greet(*self) { println("Hello, {str}!", self.name); }
}
let g = Greeter { .name "Flurry" }
g.greet(); -- 调用 greet 方法
</code></pre>
<p>注意，方法调用本身 <code>()</code> 也是一种后缀操作，与 <code>.</code> 结合使用。</p>
</li>
<li>
<p><strong>访问层级化枚举变体 (Enum Variant Access)</strong>:</p>
<pre><code class="language-flurry">enum Color { rgb.{ r: u8, g: u8, b: u8 }, hsv.{...} }
let red = Color.rgb.{ .r 255, .g 0, .b 0 } -- 使用 . 选择层级
</code></pre>
</li>
<li>
<p><strong>限定模块路径 (Module Path Qualification)</strong>: 在 <code>use</code> 语句或直接引用时，用于分隔模块路径。</p>
<pre><code class="language-flurry">use std.io.println;
std.math.sqrt(4.0); -- 使用 . 限定路径
</code></pre>
</li>
<li>
<p><strong>连接特殊后缀操作 (Connecting Special Suffix Operations)</strong>: 这是 Flurry 后缀风格的关键体现。<code>.</code> 用于连接表达式和语言内建的特殊后缀操作：</p>
<ul>
<li><strong>解引用 (<code>.*</code>)</strong>:
<pre><code class="language-flurry">let ptr = data.ref;
let value = ptr.*; -- 使用 . 连接 *
</code></pre>
</li>
<li><strong>取引用 (<code>.ref</code>)</strong>:
<pre><code class="language-flurry">let ptr = data.ref; -- 使用 . 连接 ref 关键字
</code></pre>
</li>
<li><strong>类型转换/断言 (<code>.as(TypeExpr)</code>)</strong>:
<pre><code class="language-flurry">let any_value: Any = get_value();
let specific_value = any_value.as(MyType)?; -- 使用 . 连接 as(...)
</code></pre>
</li>
<li><strong>Trait 对象转换 (<code>.dyn(TraitExpr)</code>)</strong>: (如果支持)
<pre><code class="language-flurry">let concrete_value = MyStruct {}
let trait_object = concrete_value.dyn(MyTrait); -- 使用 . 连接 dyn(...)
</code></pre>
</li>
<li><em>(可能还有其他类似 <code>.some_op(...)</code> 的内置操作)</em></li>
</ul>
</li>
</ol>
<h3 id="链式调用的优势"><a class="header" href="#链式调用的优势">链式调用的优势</a></h3>
<p>这种统一的后缀风格使得链式调用非常自然：</p>
<pre><code class="language-flurry">let result = get_data_source() -- 1. 获取数据源
    .ref                 -- 2. 获取其指针 (假设返回指针的方法)
    .process_intermediate()? -- 3. 调用处理方法 (可能返回 Result/Optional)
    .*                   -- 4. 解引用得到结果 (假设 process 返回指针)
    .filter_items(|item| item.is_valid()) -- 5. 调用过滤方法
    .map_values(|item| item.transform())   -- 6. 调用映射方法
    .collect&lt;Vec&lt;_&gt;&gt;(); -- 7. 调用收集方法，注意泛型调用也是后缀 `&lt;...&gt;()`

-- 如果没有后缀风格，代码可能看起来像：
-- let source = get_data_source();
-- let ptr = &amp;source; -- 或者 source.get_ref()
-- let intermediate_ptr = process_intermediate(ptr)?;
-- let intermediate_value = *intermediate_ptr; -- 或者 intermediate_ptr.deref()
-- let filtered = filter_items(intermediate_value, |item| item.is_valid());
-- ... 等等，更加嵌套和分散
</code></pre>
<p>链式调用使得数据处理流水线和连续操作的逻辑能够以线性的、从左到右的方式表达，更符合阅读习惯，减少了嵌套和临时变量。</p>
<h3 id="其他后缀操作"><a class="header" href="#其他后缀操作">其他后缀操作</a></h3>
<p>除了通过 <code>.</code> 连接的操作外，Flurry 还有其他重要的后缀操作：</p>
<ul>
<li><strong>取像操作 (<code>expr ' image</code>)</strong>: 获取表达式的某个“像”，如类型、标签名、位向量表示等。
<pre><code class="language-flurry">let type_info = my_variable'type;
let tag_name = my_enum_value'tag_name;
</code></pre>
</li>
<li><strong>调用操作符</strong>:
<ul>
<li><code>()</code>: 函数/方法调用。</li>
<li><code>[]</code>: 索引访问/调用。</li>
<li><code>{}</code>: <code>expr object</code> 调用 / 记录调用。</li>
<li><code>&lt;&gt;</code>: 泛型参数传递 / 钻石调用。</li>
</ul>
</li>
<li><strong>错误/可选/效应处理</strong>: <code>!</code>, <code>?</code>, <code>#</code> 通常也紧跟在表达式之后。</li>
<li><strong>字面量拓展</strong>: <code>10px</code>, <code>"s"c</code> 可以视为对字面量表达式的后缀操作。</li>
<li><strong><code>match</code> 表达式 (后缀形式)</strong>: <code>expr match { ... }</code>（如果 <code>match</code> 是后缀关键字）。</li>
</ul>
<h3 id="优先级"><a class="header" href="#优先级">优先级</a></h3>
<p>根据您提供的 <code>OpTable</code>，这些后缀操作（<code>.</code>, <code>'</code>, <code>()</code>, <code>[]</code>, <code>{}</code>, <code>&lt;&gt;</code>) 具有非常高的优先级（90-100），确保它们会紧密地绑定到其左侧的操作数（表达式），这对于链式调用的正确解析至关重要。字面量拓展对应的 <code>id</code> 甚至有更高的优先级 (110)，确保 <code>10px</code> 被视为一个整体而非 <code>10</code> 和 <code>px</code> 分开。</p>
<h3 id="总结-2"><a class="header" href="#总结-2">总结</a></h3>
<p>Flurry 对后缀操作符和语法的广泛采用，特别是万能的<strong>选择运算符 (<code>.</code>)</strong>，是其语法设计的一大特色。它极大地促进了<strong>链式调用</strong>的流畅性和代码的线性可读性，并为多种不同的操作（字段访问、方法调用、内置操作如解引用/取引用/转换）提供了一致的语法入口。这种设计选择使得 Flurry 代码在处理连续操作和数据流时显得尤为优雅和简洁。</p>
<div style="break-before: page; page-break-before: always;"></div><h2 id="取像操作-expr--image"><a class="header" href="#取像操作-expr--image">取像操作 (expr ' image)</a></h2>
<p>Flurry 引入了一种独特且强大的后缀操作符——<strong>取像操作 (<code>'</code>)</strong>，用于获取一个表达式在不同抽象层面或元数据维度的“像 (Image)”。这个操作符提供了一个统一的语法入口，访问与表达式相关的编译时信息、运行时表示或其他关联属性。</p>
<h3 id="语法-1"><a class="header" href="#语法-1">语法</a></h3>
<p>取像操作的基本语法形式为：</p>
<pre><code class="language-flurry">expression ' image_identifier
</code></pre>
<ul>
<li><strong><code>expression</code></strong>: 任何有效的 Flurry 表达式。</li>
<li><strong><code>'</code> (单引号)</strong>: 取像操作符。</li>
<li><strong><code>image_identifier</code></strong>: 一个标识符，指定想要获取的“像”的类型。这个标识符<strong>不是</strong>变量或关键字，而是由 Flurry 编译器内部识别的、用于特定取像操作的名称。</li>
</ul>
<p>根据您提供的优先级表 (<code>OpTable</code>)，取像操作符 <code>'</code> 具有很高的优先级 (100)，确保它紧密绑定其左侧的 <code>expression</code>。</p>
<h3 id="概念与用途"><a class="header" href="#概念与用途">概念与用途</a></h3>
<p>“取像”可以理解为获取表达式 <code>expression</code> 的某个特定方面或表示：</p>
<ol>
<li>
<p><strong>元数据 (Metadata)</strong>: 获取与表达式相关的元信息。</p>
<ul>
<li><code>expression ' type</code>: 获取表达式在编译时确定的<strong>类型</strong>。结果本身是一个编译时 <code>Type</code> 类型的值。
<pre><code class="language-flurry">let x = 10;
comptime let type_of_x = x'type; -- type_of_x 的值是代表 i32 (或默认整数类型) 的 Type 对象
</code></pre>
</li>
<li><code>enum_value ' tag_name</code>: 获取枚举值当前变体的<strong>名称</strong>（作为一个编译时常量字符串）。
<pre><code class="language-flurry">enum Status { ok, loading, error }
let current = Status.loading;
comptime let name = current'tag_name; -- name 的值是 "loading"
</code></pre>
</li>
</ul>
</li>
<li>
<p><strong>抽象表示 (Abstract Representation)</strong>: 获取表达式底层数据的一种抽象视图。</p>
<ul>
<li><code>value ' bitvec</code>: 获取值 <code>value</code> 在内存中的<strong>位向量 (Bit Vector)</strong> 表示。结果是一个编译时可知长度（基于 <code>value</code> 的类型）的 <code>BitVec&lt;N&gt;</code> 抽象类型，可以用于编译时的位操作（编译器会优化为高效的机器指令）。
<pre><code class="language-flurry">let flags: u8 = 0b1010_0101;
comptime let bv = flags'bitvec;
-- comptime let first_nybble = bv.slice(0..4); -- 假设 bitvec 支持切片
</code></pre>
</li>
</ul>
</li>
<li>
<p><strong>关联操作或转换 (Associated Operation / Transformation)</strong>: 触发某种与表达式相关的特殊操作。</p>
<ul>
<li><code>dst_pointer ' dst_deref</code>: (用于动态大小类型 DST) 这不是获取一个简单的值，而是触发一种特殊的<strong>解引用操作</strong>，允许对 DST 指针指向的内容进行模式匹配或访问，编译器会根据指针指向的实际数据（例如 <code>tagged_polymorphic</code> 枚举的 tag）来确定如何解释内存。</li>
<li><code>tuple ' enumerate</code>: (用于元组) 可能返回一个包含 <code>(元素, 索引)</code> 对的迭代器或编译时可展开的序列，用于 <code>inline for</code>。</li>
</ul>
</li>
</ol>
<h3 id="编译时与运行时"><a class="header" href="#编译时与运行时">编译时与运行时</a></h3>
<p>取像操作的结果可能是：</p>
<ul>
<li><strong>编译时常量</strong>: 如 <code>'type</code> 的结果是编译时 <code>Type</code>，<code>'tag_name</code> 的结果是编译时 <code>str</code>。这些结果可以直接用于 <code>comptime</code> 代码块和编译时条件判断。</li>
<li><strong>运行时值</strong>: 如 <code>'bitvec</code> 得到的是一个抽象表示，但最终的操作会生成运行时代码。<code>'dst_deref</code> 也是在运行时执行的特殊解引用。<code>'enumerate</code> 可能产生运行时迭代器。</li>
<li><strong>操作触发器</strong>: 某些“像”可能不直接返回值，而是触发编译器执行特定的分析或代码生成过程。</li>
</ul>
<p>编译器负责根据 <code>image_identifier</code> 确定具体的语义和结果类型。</p>
<h3 id="内置的-像"><a class="header" href="#内置的-像">内置的 "像"</a></h3>
<p>Flurry 语言会预定义一系列有用的 <code>image_identifier</code>。一些我们已经讨论过的或可能的例子包括：</p>
<ul>
<li><code>'type</code>: 获取编译时类型。</li>
<li><code>'tag_name</code>: 获取枚举变体名（字符串）。</li>
<li><code>'bitvec</code>: 获取位向量抽象视图。</li>
<li><code>'dst_deref</code>: 用于 DST 指针的特殊解引用/匹配。</li>
<li><code>'enumerate</code>: 用于元组或其他序列的带索引迭代。</li>
<li><em>（可能还有 <code>'size</code> 获取类型大小, <code>'alignment</code> 获取对齐, <code>'address</code> 获取地址等）</em></li>
</ul>
<p>这个列表是<strong>由语言定义和编译器内置的</strong>，开发者不能自定义新的 <code>'image_identifier</code>。</p>
<h3 id="设计优势"><a class="header" href="#设计优势">设计优势</a></h3>
<ul>
<li><strong>统一语法</strong>: 为多种不同的元信息查询和底层操作提供了一致的后缀语法。</li>
<li><strong>简洁</strong>: <code>expr'type</code> 比 <code>get_type(expr)</code> 或 <code>typeof(expr)</code> 更简洁。</li>
<li><strong>与编译时系统集成</strong>: 许多“像”直接产生编译时值，无缝融入 <code>comptime</code> 计算。</li>
<li><strong>表达力</strong>: 提供了访问语言底层信息和触发特殊操作的强大能力。</li>
</ul>
<h3 id="总结-3"><a class="header" href="#总结-3">总结</a></h3>
<p>取像操作 (<code>expr ' image</code>) 是 Flurry 中一个富有创新性的特性。它通过一个简洁的后缀操作符 <code>'</code> 和编译器内置的 <code>image_identifier</code>，提供了一个统一的接口来访问表达式的类型、元数据、抽象表示或触发特殊操作。这是 Flurry 强大的编译时元编程和底层控制能力的又一体现。</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="基本控制流-control-flow"><a class="header" href="#基本控制流-control-flow">基本控制流 (Control Flow)</a></h1>
<p>程序很少是完全线性的。根据不同的条件执行不同的代码路径，或者重复执行某段代码，是构建复杂逻辑的基础。Flurry 语言提供了结构化的控制流语句，用于引导程序的执行顺序。</p>
<p>本章将详细介绍 Flurry 中的主要控制流机制，包括：</p>
<ul>
<li><strong>条件语句</strong>: 根据布尔表达式的结果选择执行分支 (<code>if</code>, <code>when</code>)。</li>
<li><strong>循环语句</strong>: 重复执行代码块 (<code>for</code>, <code>while</code>)。</li>
<li><strong>控制转移语句</strong>: 改变正常的执行流程 (<code>break</code>, <code>continue</code>, <code>return</code>)。</li>
</ul>
<div style="break-before: page; page-break-before: always;"></div><h1 id="条件语句-conditional-statements"><a class="header" href="#条件语句-conditional-statements">条件语句 (Conditional Statements)</a></h1>
<p>条件语句允许程序根据特定条件的值来选择性地执行代码块。Flurry 主要提供 <code>if</code> 和 <code>when</code> 两种基本条件语句。</p>
<h2 id="if-语句"><a class="header" href="#if-语句"><code>if</code> 语句</a></h2>
<p><code>if</code> 语句是最基础的条件控制结构。它评估一个布尔表达式，如果结果为 <code>true</code>，则执行紧随其后的代码块；否则，可以选择性地执行 <code>else</code> 或 <code>else if</code> 分支。</p>
<p><strong>基本语法:</strong></p>
<pre><code class="language-flurry">if &lt;condition_expr&gt; {
    -- Code to execute if condition_expr is true
} else if &lt;another_condition_expr&gt; {
    -- Code to execute if another_condition_expr is true
} else {
    -- Code to execute if all preceding conditions are false
}
</code></pre>
<ul>
<li><code>&lt;condition_expr&gt;</code>: 必须是一个求值为布尔值 (<code>bool</code>) 的表达式。</li>
<li><code>{ ... }</code>: 花括号定义了与条件关联的代码块。</li>
<li><code>else if</code> 和 <code>else</code> 子句是可选的。可以有零个或多个 <code>else if</code> 子句，最多一个 <code>else</code> 子句。</li>
</ul>
<p><strong>示例:</strong></p>
<pre><code class="language-flurry">let temperature = 25;

if temperature &gt; 30 {
    println("It's hot!");
} else if temperature &lt; 10 {
    println("It's cold!");
} else {
    println("Temperature is moderate.");
}
-- 输出: Temperature is moderate.

let is_active = false;
if is_active {
    -- This block will not be executed
    println("User is active.");
}
</code></pre>
<p><strong><code>if</code> 表达式</strong>: <code>if</code> 语句也可以作为表达式使用，其每个分支必须返回兼容类型的值。</p>
<pre><code class="language-flurry">let access_level = if user.is_admin {
    "admin"
} else if user.is_moderator {
    "moderator"
} else {
    "guest"
}
-- access_level 的类型会被推断为 str (或 String)
</code></pre>
<p><strong>条件守卫 (<code>if_guard</code>)</strong>: 在其他语句（如 <code>return</code>, <code>break</code>, <code>continue</code>）后紧跟 <code>if &lt;condition_expr&gt;</code>，可以在满足条件时才执行该语句。</p>
<pre><code class="language-flurry">fn find_first_even(numbers: Slice&lt;i32&gt;) -&gt; ?i32 {
    for number in numbers {
        return number if number % 2 == 0; -- 如果 number 是偶数，则立即返回
    }
    return null; -- 没有找到偶数
}
</code></pre>
<p>这提供了一种简洁的方式来表达提前退出的逻辑。</p>
<h2 id="when-语句"><a class="header" href="#when-语句"><code>when</code> 语句</a></h2>
<p><code>when</code> 语句提供了一种更结构化的多分支选择方式，类似于其他语言中的 <code>switch</code> 或 <code>match</code> 语句，但其分支条件是任意布尔表达式。它依次评估每个分支的条件，并执行<strong>第一个</strong>条件为 <code>true</code> 的分支所对应的代码。</p>
<p><strong>基本语法:</strong></p>
<pre><code class="language-flurry">when {
    &lt;condition_expr_1&gt; =&gt; &lt;statement_or_block_1&gt;,
    &lt;condition_expr_2&gt; =&gt; &lt;statement_or_block_2&gt;,
    -- ... more branches
    -- 可选的 else 分支 (相当于 true =&gt; ...)
    _ =&gt; &lt;default_statement_or_block&gt;,
}
</code></pre>
<ul>
<li><code>=&gt;</code>: 用于分隔条件和要执行的语句或代码块。</li>
<li><code>when</code> 语句会按顺序检查 <code>&lt;condition_expr&gt;</code>，一旦找到第一个为 <code>true</code> 的条件，就执行其对应的代码，然后<strong>退出 <code>when</code> 语句</strong>（不会继续检查后续分支）。</li>
<li>可选的 <code>_ =&gt; ...</code> 分支相当于 <code>true =&gt; ...</code>，当前面所有条件都不满足时执行。如果没有 <code>_</code> 且所有条件都为 <code>false</code>，则 <code>when</code> 语句不执行任何分支。</li>
</ul>
<p><strong>示例:</strong></p>
<pre><code class="language-flurry">let status_code = 404;

when {
    status_code == 200 =&gt; println("OK"),
    status_code == 404 =&gt; println("Not Found"),
    status_code &gt;= 500 =&gt; println("Server Error"),
    else =&gt; println("Unknown Status: {}", status_code),
}
-- 输出: Not Found
</code></pre>
<p><strong><code>when</code> 表达式</strong>: 与 <code>if</code> 类似，<code>when</code> 也可以作为表达式使用，所有分支（如果存在）必须返回兼容类型的值。</p>
<pre><code class="language-flurry">let status_category = when {
    status_code &gt;= 200 and status_code &lt; 300 =&gt; "Success",
    status_code &gt;= 400 and status_code &lt; 500 =&gt; "Client Error",
    status_code &gt;= 500 =&gt; "Server Error",
    else =&gt; "Other",
}
-- status_category 将是 "Client Error"
</code></pre>
<p><strong>对比 <code>if</code>/<code>else if</code> 与 <code>when</code></strong>:</p>
<ul>
<li><code>if</code>/<code>else if</code> 链更通用，可以嵌套。</li>
<li><code>when</code> 对于多个并列条件的检查通常更清晰、更结构化，避免了深层嵌套的 <code>else if</code>。</li>
</ul>
<p>选择哪种取决于具体的逻辑和代码风格偏好。</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="循环语句-looping-statements"><a class="header" href="#循环语句-looping-statements">循环语句 (Looping Statements)</a></h1>
<p>循环语句允许程序重复执行一段代码，直到满足特定条件为止。Flurry 提供了 <code>for</code> 和 <code>while</code> 两种主要的循环结构。</p>
<h2 id="for-循环"><a class="header" href="#for-循环"><code>for</code> 循环</a></h2>
<p><code>for</code> 循环主要用于<strong>迭代</strong>一个序列或集合中的元素。它可以遍历数组、切片、范围、迭代器或其他可迭代对象。</p>
<p><strong>基本语法 (遍历迭代器):</strong></p>
<pre><code class="language-flurry">for &lt;pattern&gt; in &lt;iterable_expr&gt; {
    -- Loop body, executed for each item
}
</code></pre>
<ul>
<li><code>&lt;iterable_expr&gt;</code>: 必须是一个实现了IntoIterator或Iterator的表达式。</li>
<li><code>&lt;pattern&gt;</code>: 用于在每次迭代中绑定从迭代器获取的当前元素。可以使用简单的变量名，也可以使用更复杂的模式（如元组 <code>(index, value)</code>）。</li>
<li>循环体 <code>{ ... }</code>: 对迭代器产生的每个元素执行一次。当迭代器耗尽时，循环结束。</li>
</ul>
<p><strong>示例:</strong></p>
<pre><code class="language-flurry">let numbers = [10, 20, 30];

-- 遍历数组元素
for num in numbers {
    println("Number: {}", num);
}
-- 输出:
-- Number: 10
-- Number: 20
-- Number: 30

-- 遍历范围
for i in 0..3 { -- 遍历 0, 1, 2
    println("Index: {}", i);
}

-- 遍历并获取索引
for (index, value) in numbers.into_iter().enumerate() {
    println("Item at {}: {}", index, value);
}
</code></pre>
<p><strong>循环标签 (Loop Labels)</strong>: 可以为 <code>for</code> 循环（以及 <code>while</code> 循环）添加标签，用于在嵌套循环中精确控制 <code>break</code> 和 <code>continue</code> 的目标。标签以 <code>:</code> 结尾。</p>
<pre><code class="language-flurry">for:outer i in 0..3 {
    for:inner j in 0..3 {
        continue outer if i == 1 and j == 1; -- 跳过外层循环的剩余部分，开始下一次外层迭代
        break outer if i == 2 and j == 0; -- 完全跳出外层循环
        println("i={}, j={}", i, j);
    }
}
</code></pre>
<h2 id="while-循环"><a class="header" href="#while-循环"><code>while</code> 循环</a></h2>
<p><code>while</code> 循环会在其条件表达式求值为 <code>true</code> 时重复执行代码块。</p>
<p><strong>基本语法:</strong></p>
<pre><code class="language-flurry">while &lt;condition_expr&gt; {
    -- Loop body, executed as long as condition_expr is true
}
</code></pre>
<ul>
<li><code>&lt;condition_expr&gt;</code>: 在每次循环迭代<strong>之前</strong>进行求值。如果为 <code>true</code>，则执行循环体；如果为 <code>false</code>，则退出循环。</li>
</ul>
<p><strong>示例:</strong></p>
<pre><code class="language-flurry">let count = 0;
while count &lt; 3 {
    println("Count is: {}", count);
    count += 1;
}
-- 输出:
-- Count is: 0
-- Count is: 1
-- Count is: 2

-- 无限循环 (通常与 break 结合使用)
while true {
    let input = read_input()?; -- 假设 read_input 可能返回错误
    break if input == "quit"; -- 退出无限循环
    process(input);
}
</code></pre>
<p><strong><code>while is</code> (模式匹配循环)</strong>: Flurry 还提供了将模式匹配与 <code>while</code> 结合的循环方式，允许在每次迭代时对某个表达式的值进行模式匹配，并在匹配成功时继续循环。</p>
<p><strong>基本语法:</strong></p>
<pre><code class="language-flurry">while &lt;expr&gt; is &lt;pattern&gt; {
    -- Loop body, executed if expr matches pattern
    -- pattern 中绑定的变量在此可用
}
</code></pre>
<ul>
<li><code>&lt;expr&gt;</code>: 每次循环前求值的表达式。</li>
<li><code>&lt;pattern&gt;</code>: 用于匹配 <code>&lt;expr&gt;</code> 结果的模式。</li>
<li>只有当 <code>&lt;expr&gt;</code> 的值成功匹配 <code>&lt;pattern&gt;</code> 时，循环体才会执行。模式中绑定的变量可以在循环体中使用。当匹配失败时，循环终止。</li>
</ul>
<p><strong>示例 (处理 Option):</strong></p>
<pre><code class="language-flurry">let optional_value = 5;

while optional_value is some? { -- 只要 optional_value 是 some? 就继续
    println("Processing value: {}", some);
    -- 更新 optional_value 以便最终退出循环
    optional_value = if some &gt; 0 { some - 1 } else { null }
}
-- 输出:
-- Processing value: 5
-- Processing value: 4
-- Processing value: 3
-- Processing value: 2
-- Processing value: 1
-- Processing value: 0

println("Loop finished.");
</code></pre>
<p>这对于处理迭代器、队列或其他可能返回“哨兵值”（如 <code>null</code>, <code>EndOfFile</code>）来表示结束的数据源非常有用。</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="控制转移语句-control-transfer-statements"><a class="header" href="#控制转移语句-control-transfer-statements">控制转移语句 (Control Transfer Statements)</a></h1>
<p>控制转移语句允许程序非顺序地改变其执行流程，例如提前退出循环或函数。Flurry 提供了 <code>break</code>, <code>continue</code>, 和 <code>return</code> 三种主要的控制转移语句。</p>
<h2 id="break"><a class="header" href="#break"><code>break</code></a></h2>
<p><code>break</code> 语句用于立即<strong>终止</strong>其所在的<strong>最内层</strong>循环（<code>for</code> 或 <code>while</code>）的执行。程序控制流将跳转到该循环语句之后的下一条语句。</p>
<p><strong>示例:</strong></p>
<pre><code class="language-flurry">let numbers = [1, 5, -3, 8, 2];
let found_negative = false;

for num in numbers {
    if num &lt; 0 {
        found_negative = true;
        break; -- 找到第一个负数，立即退出 for 循环
    }
    println("Checking positive number: {}", num);
}

if found_negative {
    println("Found a negative number.");
} else {
    println("All numbers are non-negative.");
}
-- 输出:
-- Checking positive number: 1
-- Checking positive number: 5
-- Found a negative number.
</code></pre>
<p><strong>带标签的 <code>break</code></strong>: 如果存在嵌套循环，可以使用标签来指定 <code>break</code> 要终止的是<strong>哪个</strong>循环。</p>
<pre><code class="language-flurry">for:outer i in 0..5 {
    for j in 0..5 {
        if i * j &gt; 10 {
            println("Found i*j &gt; 10 at i={}, j={}. Breaking outer loop.", i, j);
            break outer; -- 终止名为 'outer' 的循环
        }
    }
}
</code></pre>
<h2 id="continue"><a class="header" href="#continue"><code>continue</code></a></h2>
<p><code>continue</code> 语句用于<strong>跳过</strong>当前循环迭代中<strong>剩余</strong>的代码，并立即开始<strong>下一次</strong>迭代。</p>
<ul>
<li>在 <code>while</code> 循环中，控制流会跳转回循环条件的判断处。</li>
<li>在 <code>for</code> 循环中，控制流会跳转到下一次迭代（获取迭代器的下一个元素）。</li>
</ul>
<p><strong>示例:</strong></p>
<pre><code class="language-flurry">for i in 0..5 {
    if i % 2 == 0 {
        continue; -- 如果 i 是偶数，跳过本次迭代的 println
    }
    println("Found odd number: {}", i);
}
-- 输出:
-- Found odd number: 1
-- Found odd number: 3
</code></pre>
<p><strong>带标签的 <code>continue</code></strong>: 与 <code>break</code> 类似，可以使用标签来指定 <code>continue</code> 要作用于哪个嵌套循环。</p>
<pre><code class="language-flurry">for:outer i in 0..3 {
    for j in 0..3 {
        if i == 1 {
            println("Skipping outer iteration for i=1");
            continue outer; -- 跳过外层循环 i=1 的剩余部分，直接开始 i=2
        }
        println("Processing i={}, j={}", i, j);
    }
}
</code></pre>
<h2 id="return"><a class="header" href="#return"><code>return</code></a></h2>
<p><code>return</code> 语句用于从当前<strong>函数</strong>中退出，并可选地将一个值返回给函数的调用者。</p>
<p><strong>语法:</strong></p>
<pre><code class="language-flurry">return;             -- 从返回 void 的函数退出
return &lt;value_expr&gt;; -- 从返回特定类型的函数退出，并返回值
</code></pre>
<ul>
<li><code>&lt;value_expr&gt;</code>: 其类型必须与函数签名中声明的返回类型兼容。</li>
<li>一旦执行 <code>return</code> 语句，函数立即终止，控制权交还给调用点。</li>
</ul>
<p><strong>示例:</strong></p>
<pre><code class="language-flurry">fn check_age(age: u32) -&gt; bool {
    if age &lt; 18 {
        println("Too young.");
        return false; -- 提前返回 false
    }
    println("Age is sufficient.");
    return true; -- 返回 true
}

fn process() {
    println("Processing start.");
    if some_condition() {
        return; -- 提前退出 process 函数 (假设 process 返回 void)
    }
    println("Processing continued.");
    -- ...
    println("Processing end.");
}
</code></pre>
<p><strong><code>return</code> 与 <code>if_guard</code></strong>: <code>return</code> 可以与条件守卫结合使用，形成简洁的提前返回模式。</p>
<pre><code class="language-flurry">fn get_user(id: Uuid) -&gt; ?User {
    let data = database.fetch(id)?; -- 假设 ? 用于错误传播或 Option 解包
    return null if data.is_empty(); -- 如果数据为空，提前返回 null
    -- ... process non-empty data ...
    User.from(data)
}
</code></pre>
<p><strong>总结</strong>: <code>break</code>, <code>continue</code>, 和 <code>return</code> 是控制程序非线性执行流程的基本工具。<code>break</code> 和 <code>continue</code> 主要用于控制循环，而 <code>return</code> 用于退出函数。标签的使用为嵌套结构提供了更精确的控制能力。</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="函数-functions"><a class="header" href="#函数-functions">函数 (Functions)</a></h1>
<p>函数是 Flurry 程序中执行特定任务的基本代码单元。它们封装了可重用的逻辑，接收输入参数，执行计算，并可能返回一个结果。Flurry 的函数系统设计灵活，支持多种参数类型、泛型、编译时计算以及与类型系统紧密集成的方法。</p>
<p>本章将全面介绍 Flurry 中的函数，包括：</p>
<ul>
<li><strong>函数定义与调用</strong>: 如何声明和使用函数。</li>
<li><strong>参数详解</strong>: 不同种类的函数参数及其用法。</li>
<li><strong>返回值</strong>: 函数如何返回值，以及集成的错误处理机制。</li>
<li><strong>方法</strong>: 如何在类型（如 <code>struct</code>, <code>enum</code>）上定义函数。</li>
<li><strong>泛型函数</strong>: 如何编写可处理多种类型的通用函数。</li>
</ul>
<p>函数是组织和构建 Flurry 程序的核心构件。</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="定义与调用-definition--invocation"><a class="header" href="#定义与调用-definition--invocation">定义与调用 (Definition &amp; Invocation)</a></h1>
<h2 id="函数定义-function-definition"><a class="header" href="#函数定义-function-definition">函数定义 (Function Definition)</a></h2>
<p>使用 <code>fn</code> 关键字定义一个函数。其基本语法结构如下：</p>
<pre><code class="language-flurry">pub? (comptime|async|...)? fn function_name(parameter*) ReturnType? clause? block
</code></pre>
<p><strong>示例:</strong></p>
<pre><code class="language-flurry">-- 简单的加法函数
fn add(a: i32, b: i32) -&gt; i32 {
    a + b -- 函数体最后是表达式，隐式返回其值
}

-- 无返回值的函数
pub fn print_greeting(name: String) { -- 等同于 -&gt; void
    println("Hello, {}!", name);
}

-- print_value: for&lt;T:- Display&gt; fn(T)
fn print_value(value: T) where T:- Display {
    println("Value: {}", value);
}
</code></pre>
<h2 id="函数调用-function-invocation"><a class="header" href="#函数调用-function-invocation">函数调用 (Function Invocation)</a></h2>
<p>调用函数使用函数名，后跟圆括号 <code>()</code>，括号内提供实际参数（也称为实参，arguments）。</p>
<pre><code class="language-flurry">let sum = add(5, 3); -- 调用 add 函数，传递 5 和 3 作为参数
print_greeting("Flurry".to_string()); -- 调用 print_greeting

-- 调用泛型函数时，编译时参数可能需要显式提供或由编译器推断
-- print_value&lt;i32&gt;(10);
print_value(10); -- 编译器通常可以推断 T 为 i32
</code></pre>
<p>参数传递的规则取决于函数签名中参数的类型（详见 <a href="core/functions/parameters.html">参数详解</a>）。</p>
<h2 id="方法-methods"><a class="header" href="#方法-methods">方法 (Methods)</a></h2>
<p>函数也可以直接<strong>关联</strong>到某个类型（如 <code>struct</code>, <code>enum</code>, <code>union</code>, <code>mod</code>）上。定义在类型内部的函数称为<strong>关联函数</strong>。</p>
<p><strong>定义:</strong></p>
<p>关联函数直接在类型定义的 <code>{}</code> 内部使用 <code>fn</code> 定义。</p>
<pre><code class="language-flurry">struct Point {
    x: f64,
    y: f64,

    pub fn origin() -&gt; Self { -- Self 是当前类型的别名
        Point { .x 0.0, .y 0.0 }
    }

    -- 通常称为“方法”
    pub fn distance_from_origin(*self) -&gt; f64 {
        -- self 指向调用该方法的实例
        math.sqrt(self.x * self.x + self.y * self.y)
    }

    -- 接收可变引用的方法
    pub fn translate(*self, dx: f64, dy: f64) {
        self.x += dx;
        self.y += dy;
    }

     -- 接收所有权的方法
    -- pub fn consume(self) { {- ... -} }
}
</code></pre>
<p><strong>调用:</strong></p>
<pre><code class="language-flurry">let p1 = Point.origin(); -- 调用静态方法 origin
let p2 = Point { .x 3.0, .y 4.0 }

let dist = p2.distance_from_origin(); -- 调用实例方法 distance_from_origin
println("Distance: {}", dist);       -- 输出: Distance: 5.0

let p3 = Point.origin();
p3.translate(1.0, 2.0); -- 调用可变实例方法 translate
println("Translated: ({}, {})", p3.x, p3.y); -- 输出: Translated: (1.0, 2.0)
</code></pre>
<p>方法调用 <code>instance.method(args...)</code> 通常是 <code>TypeName.method(instance.ref, args...)</code>等形式的语法糖。</p>
<p><strong>实现块 (<code>impl</code>) 中的方法:</strong></p>
<p>除了直接在类型定义中，也可以在单独的 <code>impl TypeName { ... }</code> 或 <code>impl TraitName for TypeName { ... }</code> 块中为类型定义函数、子成员等。</p>
<pre><code class="language-flurry">struct Counter { value: i32 }

-- 在 impl 块中为 Counter 添加方法
impl Counter {
    fn new() -&gt; Self { Counter { .value 0 } }
    fn increment(*self) { self.value += 1; }
    fn get(*self) -&gt; i32 { self.value }
}

test {
    let c = Counter.new();
    c.increment();
    println("Count: {}", c.get()); -- 输出: Count: 1
}
</code></pre>
<p>这种方式有助于将类型的定义和其行为实现分开</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="参数详解-parameter-details"><a class="header" href="#参数详解-parameter-details">参数详解 (Parameter Details)</a></h1>
<p>函数通过参数接收输入数据。Flurry 提供了多种参数类型，以满足不同的编程需求和代码风格。</p>
<h2 id="1-普通参数-positional-parameters"><a class="header" href="#1-普通参数-positional-parameters">1. 普通参数 (Positional Parameters)</a></h2>
<p>这是最基本的参数形式，通过位置进行传递。</p>
<p><strong>定义:</strong> <code>parameter_name: Type</code></p>
<pre><code class="language-flurry">fn process_data(data: Slice&lt;u8&gt;, length: usize) { {- ... -} }
</code></pre>
<p><strong>调用:</strong> 按定义顺序提供值。</p>
<pre><code class="language-flurry">let buffer = [1, 2, 3];
process_data(buffer[..], buffer.len());
</code></pre>
<h2 id="2-可选参数-optional-parameters"><a class="header" href="#2-可选参数-optional-parameters">2. 可选参数 (Optional Parameters)</a></h2>
<p>参数类型为<code>option type</code>, 则可以选择性传递该参数，不传递则传递<code>null</code>。</p>
<p><strong>定义:</strong> <code>parameter_name: ?Type</code></p>
<pre><code class="language-flurry">-- timeout 是一个可选的毫秒数
fn connect(address: String, timeout: ?u64) -&gt; bool {
    let resolved_timeout = timeout.unwrap_or(5000); -- 使用默认值 5000ms
    -- ... 连接逻辑使用 resolved_timeout ...
    true -- 假设连接成功
}
</code></pre>
<p><strong>调用:</strong></p>
<pre><code class="language-flurry">connect("example.com".to_string()); -- 不提供超时
connect("example.com".to_string(), 10000); -- 提供 10 秒超时
</code></pre>
<h2 id="3-具名参数-named-parameters"><a class="header" href="#3-具名参数-named-parameters">3. 具名参数 (Named Parameters)</a></h2>
<p>用于提高函数调用的可读性，尤其是在参数较多或参数意义不明显时。</p>
<p><strong>定义:</strong> <code>.parameter_name: Type = default_value</code></p>
<ul>
<li>必须以点 <code>.</code> 开头。</li>
<li>必须提供一个默认值。</li>
</ul>
<pre><code class="language-flurry">-- 配置选项通常使用具名参数
fn configure_service(
    .retries: usize = 3,
    .use_tls: bool = true,
    .log_level: LogLevel = LogLevel.info, 
) { {- ... -} }
</code></pre>
<p><strong>调用:</strong> 调用时<strong>必须</strong>使用参数名，顺序任意。可以省略使用默认值的参数。</p>
<pre><code class="language-flurry">-- 使用部分默认值
configure_service(.log_level = LogLevel.Debug);

-- 指定多个参数，顺序随意
configure_service(.use_tls = false, .retries = 5);

-- 使用所有默认值
configure_service();

-- configure_service(5, false); -- 错误！必须使用名称
</code></pre>
<h2 id="4-变长参数-variadic-parameters"><a class="header" href="#4-变长参数-variadic-parameters">4. 变长参数 (Variadic Parameters)</a></h2>
<p>允许函数接受不定数量的参数。</p>
<p><strong>定义:</strong> <code>...parameter_name: TupleType</code> (通常放在最后)</p>
<ul>
<li>使用 <code>...</code> 前缀。</li>
<li>调用时传递给该部分的所有参数会被收集到一个<strong>元组 (tuple)</strong> 中。</li>
<li><code>TupleType</code> 指定了期望的元组类型。</li>
</ul>
<p><strong>调用:</strong> 正常传递参数，它们会被自动收集。</p>
<pre><code class="language-flurry">-- 接受任意数量 i32 的函数
fn sum_all(...numbers: T) -&gt; i32 
where T, requires Type.is_tuple(T)
{
    let total = 0;
    inline for num in numbers {
        inline if num'type != i32 {
            build.error("All arguments must be i32");
        } else {
            total += num;
        }
    }
    total
}

test {
    println("Sum: {}", sum_all(1, 2, 3, 4)); -- numbers 是 (1, 2, 3, 4)
    println("Sum: {}", sum_all(10));         -- numbers 是 (10,)
    println("Sum: {}", sum_all());           -- numbers 是 ()
}
</code></pre>
<p><strong>编译时类型安全的变长参数</strong>: 结合 <code>comptime</code> 参数，可以实现一些依赖类型特性。</p>
<pre><code class="language-flurry">-- format 在编译时确定，varargs 的类型也随之确定
fn println(comptime format: str, ...varargs: fmt.Args(format)) {
    -- 内部使用 inline for 安全处理
    -- ...
}
</code></pre>
<p><strong>双变参调用</strong>: Flurry 支持一种特殊的双变参函数和调用语法，用于构建 DSL。（详见相关章节）</p>
<h2 id="5-隐式参数-implicit-parameters"><a class="header" href="#5-隐式参数-implicit-parameters">5. 隐式参数 (Implicit Parameters)</a></h2>
<p>由编译器自动提供的参数，无需在调用点显式传递。</p>
<p><strong>定义:</strong> <code>implicit parameter_name: Type</code></p>
<pre><code class="language-flurry">-- 获取源代码位置
fn log(message: String, implicit __src__: builtin.SourceLocation) {
    println("{}:{}: {}", src.file, src.line, message);
}
</code></pre>
<p><strong>调用:</strong> 调用者像调用普通函数一样，编译器负责查找并传入合适的隐式参数。</p>
<pre><code class="language-flurry">-- let memory = allocate_memory(1024); -- 编译器自动传入默认分配器
log("Initialization complete.");    -- 编译器自动传入调用点的源代码位置
</code></pre>
<p>隐式参数的解析规则（如何查找、优先级等）需要语言明确定义。它们是实现上下文传递、依赖注入等模式的有力工具。</p>
<h2 id="6-编译时参数-comptime"><a class="header" href="#6-编译时参数-comptime">6. 编译时参数 (<code>comptime</code>)</a></h2>
<p>参数值必须在编译时可知。</p>
<p><strong>定义:</strong> <code>comptime parameter_name: Type</code></p>
<ul>
<li>可以与其他参数种类（普通、可选、具名、变长）结合。</li>
<li>值在编译时确定。</li>
<li>后续参数的类型或值可以依赖于前面的 <code>comptime</code> 参数（<strong>依赖类型</strong>）。</li>
</ul>
<pre><code class="language-flurry">-- T 和 N 都是编译时参数
fn create_array(initial_value: T) -&gt; Array&lt;T, N&gt;
    where T:- Copy, N: usize -- 约束 T 必须是可复制的，N 必须是无符号整数
{
    Array&lt;T, N&gt;.new(initial_value) -- 使用 T 和 N 创建数组
}

-- alignment 必须是编译时常量
fn aligned_alloc(size: usize, comptime alignment: usize) -&gt; !AllocErr *u8 {
    -- ... 使用 alignment 进行内存分配 ...
}

test {
    let arr = create_array(0); -- T 是 i32，N 是 10
    println("Array: {:?}", arr);

    let ptr = aligned_alloc(1024, 16)!; -- alignment 是 16
    println("Aligned pointer: {:?}", ptr);
}
</code></pre>
<p><code>comptime</code> 参数是 Flurry 实现泛型、元编程和零成本抽象的关键。每次使用不同的编译时参数调用函数时，编译器会生成一个该函数特化（单态化）的版本。</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="返回值与错误处理-"><a class="header" href="#返回值与错误处理-">返回值与错误处理 (!)</a></h1>
<p>函数通过返回值将其计算结果或状态传递给调用者。Flurry 提供了标准的返回值机制，并内置了一套用于处理可恢复错误的、基于类型系统的机制。</p>
<h2 id="返回值-return-values"><a class="header" href="#返回值-return-values">返回值 (Return Values)</a></h2>
<p>使用 <code>-&gt; ReturnType</code> 在函数签名中指定返回值的类型。</p>
<ul>
<li><strong>隐式返回</strong>: 如果函数体的最后一个表达式的类型与 <code>ReturnType</code> 兼容，该表达式的值将自动作为返回值，无需 <code>return</code> 关键字。
<pre><code class="language-flurry">fn double(x: i32) -&gt; i32 {
    x * 2 -- 表达式 x * 2 的值被隐式返回
}
</code></pre>
</li>
<li><strong>显式返回</strong>: 使用 <code>return</code> 关键字可以从函数体的任何位置提前返回一个值。
<pre><code class="language-flurry">fn find_char(s: String, target: char) -&gt; ?usize { -- 返回 ?usize
    for (i, c) in s.chars().enumerate() {
        return i if c == target; -- 找到，提前返回 Some(index)
    }
    null -- 循环结束都没找到，返回 null
}
</code></pre>
</li>
<li><strong><code>void</code> 返回类型</strong>: 如果函数不返回有意义的值，返回类型为 <code>void</code>。可以省略 <code>-&gt; void</code>。
<pre><code class="language-flurry">fn print_message(msg: String) { -- 隐式返回 void
    println("{}", msg);
}
</code></pre>
</li>
</ul>
<h2 id="错误处理-errors-t"><a class="header" href="#错误处理-errors-t">错误处理 (<code>!Errors T</code>)</a></h2>
<p>Flurry 提供了一种内置的、类型安全的方式来处理函数中可能发生的可恢复错误，避免了 C 的错误码、Java 的检查异常或 Go 的显式 <code>if err != nil</code> 的某些缺点。</p>
<p><strong><code>!Errors T</code> 返回类型</strong>:</p>
<ul>
<li>当一个函数可能成功并返回 <code>T</code> 类型的值，或者失败并返回多种可能的错误类型之一时，可以使用 <code>!Errors T</code> 作为返回类型。</li>
<li><code>Errors</code>: 通常是一个<strong>编译时已知的类型列表</strong>（或单个枚举类型），代表该函数可能返回的所有错误类型。</li>
</ul>
<p><strong>语法:</strong></p>
<pre><code class="language-flurry">-- 可能返回 u32，或 FileNotFoundErr, 或 PermissionDenied 错误
fn read_config_value(path: String) -&gt; ![FileNotFoundErr, PermissionDenied] u32 {
    -- ... 函数体 ...
}
</code></pre>
<p><strong>错误传播 (<code>expr!</code>)</strong>:</p>
<p>当调用一个返回 <code>!Errors T</code> 类型的函数时，可以使用后缀操作符 <code>!</code> 简洁地传播错误。</p>
<ul>
<li>如果 <code>expr</code> 的结果匹配 <code>value!</code>，<code>expr!</code> 会解包得到 <code>value</code>。</li>
<li>如果 <code>expr</code> 的结果匹配 <code>error e</code>，<code>expr!</code> 会<strong>立即从当前函数返回</strong>这个 <code>e</code> 值。<strong>前提是当前函数的返回类型也必须是 <code>!Errors' T'</code>，并且 <code>Errors'</code> 包含 <code>e'type</code>（或者可以自动转换/融合）</strong>。</li>
</ul>
<pre><code class="language-flurry">struct Config { {- ... -} }

fn parse_config(content: String) -&gt; !ParseErr Config { {- ... -} }
fn read_file(path: String) -&gt; !IoErr String { {- ... -} }

pub const Errors = [IoErr, ParseErr, NetworkErr];
-- load_config 可能返回
fn load_config(path: String) -&gt; !Errors Config {
    -- read_file返回值的错误负载必须是Errors的子集或元素
    let content = read_file(path)!;
    let config = parse_config(content)!;

    config
}
</code></pre>
<p><code>!</code> 操作符极大地简化了错误传递的样板代码。</p>
<p><strong>错误处理 (<code>expr! { ... }</code>)</strong>:</p>
<p>如果你想在错误发生的地方<strong>立即处理</strong>它，而不是直接传播，可以使用 <code>expr! { ... }</code> 块。</p>
<ul>
<li>它允许你为 <code>expr</code> 可能返回的不同错误类型提供匹配分支。</li>
</ul>
<pre><code class="language-flurry">fn get_data_or_default(source: DataSource) -&gt; Data {
    let result = source.fetch_data()! { -- 处理 fetch_data 可能的错误
        .NetworkErr(err) =&gt; log("Network failed: {}", err),
        .AuthErr =&gt; {
            source.re_authenticate()! {
                {- ... -}
            }
        },
        _ as e =&gt; log("Unhandled fetch error: {}", e'tag_name),
        catch e =&gt; return Data.default(),
    }
    result
}
</code></pre>
<p><strong>自动枚举融合</strong>:</p>
<p>当一个函数调用多个可能返回不同错误集的函数时，编译器可以<strong>自动推导</strong>并<strong>融合</strong>所有可能的错误类型，形成当前函数签名所需的 <code>Errors</code> 集合。详见<a href="core/functions/advanced/error_handling/fusion.html">自动枚举融合</a>。</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="数据结构-data-structures"><a class="header" href="#数据结构-data-structures">数据结构 (Data Structures)</a></h1>
<p>数据结构是组织和存储数据的方式，是构建任何复杂程序的基础。Flurry 提供了多种内置的数据结构类型，用于表示不同形式的数据集合，并允许开发者定义自己的复杂数据类型。</p>
<p>Flurry 的一个核心设计理念是，<strong>类型定义本身就是一个完备的命名空间</strong>。这意味着像结构体 (<code>struct</code>)、枚举 (<code>enum</code>)、联合体 (<code>union</code>) 甚至模块 (<code>mod</code>) 这些用于定义类型的关键字，它们所创建的不仅仅是数据的蓝图，更是一个可以包含常量、静态变量、嵌套类型定义以及关联函数（方法）的作用域。</p>
<p>本章将深入探讨 Flurry 中主要的内置和用户自定义数据结构：</p>
<ul>
<li><strong>结构体 (Structs)</strong>: 将不同类型的数据组合成一个逻辑单元。</li>
<li><strong>枚举 (Enums)</strong>: 定义一个可以持有多种不同变体之一的类型。</li>
<li><strong>联合体 (Unions)</strong>: 允许多个字段共享同一块内存空间（需要谨慎使用）。</li>
<li><strong>数组与切片 (Arrays &amp; Slices)</strong>: 处理固定大小和动态大小的同质数据序列。</li>
<li><strong>元组 (Tuples)</strong>: 轻量级的、匿名的、固定大小的异质数据序列。</li>
<li><strong>模块作为类型 (Modules as Types)</strong>: 理解模块本身也是一种包含成员的类型。</li>
<li><strong>Newtypes</strong>: 创建基于现有类型的新类型，以增强类型安全。</li>
</ul>
<p>理解这些数据结构及其作为命名空间的行为，是掌握 Flurry 类型系统和组织复杂代码的关键。</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="结构体-structs"><a class="header" href="#结构体-structs">结构体 (Structs)</a></h1>
<p>结构体（Struct）是 Flurry 中最基本的用户自定义数据类型之一。它允许你将多个不同类型的值组合在一起，形成一个有意义的、命名的复合类型。</p>
<p><strong>定义结构体</strong></p>
<p>使用 <code>struct</code> 关键字来定义结构体，并在花括号 <code>{}</code> 内声明其字段（成员变量）。每个字段都有一个名称和一个类型注解。</p>
<pre><code class="language-flurry">struct Point {
    x: f64,
    y: f64,
}

struct Color {
    red: u8,
    green: u8,
    blue: u8,
}

struct UserProfile {
    username: String,
    email: String,
    is_active: bool,
    login_count: u64,
}
</code></pre>
<p><strong>实例化结构体</strong></p>
<p>定义了结构体后，你可以创建它的实例。Flurry 使用类似 <code>TypeName { .field1 value1, ... }</code> 的语法来初始化结构体实例，这正是我们之前讨论过的 "双变参调用" 语法的一种应用，这里没有传递 "children"，只传递了 "attributes"（字段）。</p>
<pre><code class="language-flurry">let origin = Point { .x 0.0, .y 0.0 }

let white = Color { .red 255, .green 255, .blue 255 }

let user = UserProfile {
    .username "alice".to_string(),
    .email "alice@example.com".to_string(),
    .is_active true,
    .login_count 5,
}
</code></pre>
<p>字段初始化的顺序通常不重要，但必须提供所有非可选字段的值（除非它们有默认值，这需要语言支持）。</p>
<p><strong>访问字段</strong></p>
<p>使用点 (<code>.</code>) 操作符来访问结构体实例的字段。</p>
<pre><code class="language-flurry">println("Origin point: ({}, {})", origin.x, origin.y); -- 输出: Origin point: (0.0, 0.0)

let user_email = user.email;
</code></pre>
<p>如果字段是可变的 (<code>mut</code>)，且实例绑定也是可变的 (<code>let ...</code>)，则可以修改字段的值：</p>
<pre><code class="language-flurry">let user = user;
user.login_count += 1;
</code></pre>
<p><strong>结构体作为命名空间</strong></p>
<p>如前所述，<code>struct</code> 定义本身就是一个命名空间。你可以在 <code>struct</code> 定义的花括号内直接定义关联函数（通常称为<strong>方法</strong>）。方法通常接收 <code>*self</code> (指针), 或 <code>self</code> (获取所有权) 作为第一个参数，用于访问或修改实例数据。</p>
<pre><code class="language-flurry">struct Rectangle {
    width: u32,
    height: u32,

    pub fn area(*self) -&gt; u32 {
        self.width * self.height -- 通过 self 访问实例字段
    }

    pub fn square(size: u32) -&gt; Self { -- Self 是类型的别名
        Rectangle { .width size, .height size }
    }
}

test {
    let rect = Rectangle { .width 10, .height 5 }
    println("Area: {}", rect.area()); -- 调用实例方法: 输出 Area: 50

    let sq = Rectangle.square(8);
    println("Square area: {}", sq.area()); -- 输出 Square area: 64
}
</code></pre>
<ul>
<li>方法定义在 <code>struct { ... }</code> 内部。</li>
<li>使用 <code>.</code> 操作符调用实例方法 (<code>rect.area()</code>)。</li>
<li>使用 <code>.</code> 调用选取符号 (<code>Rectangle.square(8)</code>)。</li>
</ul>
<p><strong>组合与委托 (<code>using</code>)</strong></p>
<p>结构体可以通过 <code>using</code> 关键字将内部字段的成员暴露出来，简化接口。</p>
<pre><code class="language-flurry">struct Person {
    name: String,
    pub fn greet(*self) { println("Hello, I'm {}", self.name); }
}

struct Employee {
    person: Person,
    employee_id: u32,
    using person.*; -- 将 Person 的 greet 方法提升到 Employee
}

test {
    let emp = Employee {
        .person Person { .name "Bob".to_string() },
        .employee_id 123,
    }
    emp.greet(); -- 直接调用 greet，无需 emp.person.greet()
                 -- 输出: Hello, I'm Bob
}
</code></pre>
<p>结构体是 Flurry 中构建复杂数据模型的核心工具，结合其作为命名空间的能力和属性系统，提供了强大的定制化和组织能力。</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="枚举-enums"><a class="header" href="#枚举-enums">枚举 (Enums)</a></h1>
<p>枚举（Enum）是 Flurry 中用于定义一个“类型可以是多种可能变体之一”的数据结构。它允许你将一组相关的、但结构可能不同的数据类型聚合在一个统一的类型名下。</p>
<p><strong>定义枚举</strong></p>
<p>使用 <code>enum</code> 关键字定义枚举，并在花括号 <code>{}</code> 内列出其所有可能的<strong>变体 (variants)</strong>。每个变体可以：</p>
<ul>
<li>只是一个简单的名字（像 C 语言的枚举）。</li>
<li>包含关联数据（像 Rust 或 Swift 的代数数据类型 ADT）。</li>
</ul>
<pre><code class="language-flurry">-- 简单的状态枚举
enum Status {
    ok,
    pending,
    error,
}

-- 带有数据的枚举 (表示不同形状)
enum Shape {
    circle(radius: f64),
    rectangle(width: f64, height: f64),
    point, -- 也可以有不带数据的变体
}

-- 层级化枚举 (之前讨论过)
enum AstNode {
    expr.{ -- 使用 '.' 定义层级
        literal(LiteralKind),
        binary_op(Op, *AstNode, *AstNode),
    },
    stmt.{
        let_binding(String, *AstNode),
        return_stmt(?*AstNode),
    },
}
</code></pre>
<p><strong>实例化枚举</strong></p>
<p>实例化枚举需要指定要创建的变体，并提供其所需的关联数据（如果有的话）。访问变体通常使用 <code>EnumName.VariantName</code> 的形式。</p>
<pre><code class="language-flurry">let current_status = Status.pending;

let my_shape = Shape.rectangle(10.0, 5.5);
let origin_point = Shape.point;

let node = AstNode.expr.literal(LiteralKind.integer(10));
</code></pre>
<p><strong>模式匹配枚举</strong></p>
<p>枚举最常用的场景是与<strong>模式匹配</strong>（<code>match</code>, <code>if is</code>, <code>while is</code>）结合使用，以根据枚举实例当前持有的变体来执行不同的代码。</p>
<pre><code class="language-flurry">fn process_status(status: Status) {
    if status is {
        .ok =&gt; println("Status is OK."),
        .pending =&gt; println("Status is Pending."),
        .error =&gt; println("Status is Error."),
        -- `match` 需要是穷尽的
    }
}

fn calculate_area(shape: Shape) -&gt; f64 {
    if shape is {
        .circle(r) =&gt; 3.14159 * r * r, -- 解构出关联数据 r
        .rectangle(w, h) =&gt; w * h,   -- 解构出 w 和 h
        .point =&gt; 0.0,
    }
}

test {
    process_status(current_status); -- 输出: Status is Pending.
    let area = calculate_area(my_shape); -- area 会是 55.0
    println("Shape area: {}", area);
}
</code></pre>
<p><strong>枚举作为命名空间与关联函数</strong></p>
<p>与结构体类似，<code>enum</code> 定义本身也是一个命名空间，可以在其 <code>{}</code> 内部定义关联函数（方法）或静态函数。</p>
<pre><code class="language-flurry">enum IpAddr {
    v4(u8, u8, u8, u8),
    v6(String), -- 简化表示

    pub fn display(*self) {
        if self is {
            .v4(a, b, c, d) =&gt; println("{}.{}.{}.{}", a, b, c, d),
            .v6(s) =&gt; println("{}", s),
        }
    }

    pub fn loopback_v4() -&gt; Self {
        IpAddr.v4(127, 0, 0, 1)
    }
}

test {
    let home = IpAddr.loopback_v4();
    home.display(); -- 输出: 127.0.0.1
    let work = IpAddr.v6("::1".to_string());
    work.display(); -- 输出: ::1
}
</code></pre>
<p><strong>层级化与融合</strong></p>
<p>Flurry 支持<strong>层级化枚举</strong> (<code>enum.group.variant</code>) 和<strong>枚举融合</strong> (<code>meta.Enum.from(...)</code>)，提供了强大的组织和组合枚举的能力。（详见 <a href="core/data_structures/enums/hierarchy_fusion.html">层级化与融合</a>）</p>
<p>枚举是 Flurry 中表示“和或”类型（Sum Types）的关键工具，结合模式匹配，使得处理具有多种可能形态的数据变得安全和方便。</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="层级化与融合"><a class="header" href="#层级化与融合">层级化与融合</a></h1>
<p>Flurry 的枚举 (<code>enum</code>) 不仅仅是像 C 或 Java 中那样简单的标签列表，也不完全等同于 Rust 中强大的代数数据类型 (ADT)。Flurry 在枚举的设计上引入了两个极具特色的创新：<strong>层级化定义 (Hierarchical Definition)</strong> 和 <strong>枚举融合 (Enum Fusion)</strong>。这两个特性相互配合，极大地增强了枚举的组织能力和组合性，尤其是在处理复杂状态空间或像错误类型这样需要组合的场景时。</p>
<p><strong>1. 层级化枚举：给变体一个“家谱”</strong></p>
<p>想象一下，你在为编译器定义抽象语法树 (AST) 节点类型。你可能会有各种二元操作符（加、减、乘、除、与、或、比较等）、一元操作符（取反、负号）、字面量（整数、浮点数、字符串）等等。如果把它们都平铺在一个巨大的枚举里，列表会很长，而且逻辑分组也不明显。</p>
<p>Flurry 的<strong>层级化枚举</strong>允许你像组织文件目录一样来组织枚举的变体：</p>
<pre><code class="language-flurry">enum AstNodeKind {
    -- 使用 '.' 来创建层级
    unary.{ -- 'unary' 组
        bool_not, -- 路径是 unary.bool_not
        neg,      -- 路径是 unary.neg
    },
    binary.{ -- 'binary' 组
        add, sub, mul, div, -- 直接成员：binary.add 等
        bool.{ -- 'binary' 下的 'bool' 子组
            and, -- 路径是 binary.bool.and
            or,
            eq, ne, lt, le, gt, ge, -- binary.bool.eq 等
        },
        -- 可以继续嵌套其他二元操作符分组...
    },
    literal.{ -- 'literal' 组
        int, float, string, char, -- literal.int 等
    },
    variable_ref, -- 顶层变体
    function_call, -- 顶层变体
    -- ... 其他节点类型 ...
}

-- 如何使用？
test {
    let node_type = AstNodeKind.binary.bool.eq; -- 使用完整的层级路径访问变体

    if node_type is {
        -- 可以在模式匹配中使用层级
        .binary.bool.eq =&gt; println("Equality comparison"),
        -- 使用通配符匹配整个分组
        .binary.bool.* =&gt; println("Some boolean binary operation"),
        .unary.* =&gt; println("Some unary operation"),
        .literal.int =&gt; println("Integer literal"),
        _ =&gt; println("Other node type"),
    }
}
</code></pre>
<ul>
<li><strong>语法</strong>: 使用点 <code>.</code> 和花括号 <code>{}</code> 来创建层级。点号用于分隔层级名称，花括号用于包含子层级或同一层级的多个变体。</li>
<li><strong>优点</strong>:
<ul>
<li><strong>组织性</strong>: 极大地提高了大型枚举的可读性和可维护性。</li>
<li><strong>命名空间</strong>: 天然地为变体提供了命名空间，减少命名冲突（例如，可以有 <code>binary.add</code> 和 <code>vector.add</code> 而不冲突）。</li>
<li><strong>逻辑分组</strong>: 枚举的结构可以直接反映概念上的分类。</li>
<li><strong>模式匹配增强</strong>: 可以在 <code>match</code> 或 <code>if is</code> 中使用层级路径和通配符 (<code>*</code>) 进行更结构化的匹配。</li>
</ul>
</li>
<li><strong>本质</strong>: 尽管看起来有层级，但在底层实现中，每个最终的变体（如 <code>binary.bool.and</code>）仍然是一个唯一的标签或标识符。层级化主要体现在<strong>语法层面</strong>的组织和访问方式上。</li>
</ul>
<p><strong>2. 枚举融合：将不同的世界合并</strong></p>
<p>现在，假设不同的库或模块定义了各自的枚举，比如网络库定义了 <code>NetErr</code>，文件系统库定义了 <code>FsErr</code>。在某个函数中，你可能同时遇到这两种错误。你需要一种方法来统一处理它们，但又不想手动创建一个包含所有可能错误的新枚举（这很繁琐且难以维护）。</p>
<p>这就是<strong>枚举融合 (Enum Fusion)</strong> 发挥作用的地方。Flurry 允许你在编译时将多个独立的枚举**“融合”**成一个新的、统一的枚举类型。</p>
<pre><code class="language-flurry">-- --- 在库 A 中定义 ---
mod lib_a {
    pub enum ErrorA {
        Timeout,
        ConnectionFailed,
    }

    derive Eq for ErrorA;
}

-- --- 在库 B 中定义 ---
mod lib_b {
    pub enum ErrorB {
        NotFound,
        PermissionDenied,
    }

    derive Eq for ErrorB;
}

-- --- 在使用代码中融合 ---
use lib_a.ErrorA;
use lib_b.ErrorB;

-- 使用编译时元函数 (假设语法) 创建一个新的融合枚举类型 C
-- C 现在包含了来自 ErrorA 和 ErrorB 的所有变体，并保留了它们的“来源”信息
-- 自动实现相关Into与From
newtype C = meta.Enum.from([ErrorA, ErrorB]);
derive Eq for C;

-- 演示融合后的类型
fn might_fail_combined() -&gt; C {
    if condition1 {
        ErrorA.Timeout.into()
    } else if condition2 {
        ErrorB.NotFound.into();
    } else {
        -- ... 其他情况 ...
    }
}

test {
    let result: C = might_fail_combined();

    -- 可以使用原始枚举的层级路径 (加上来源) 来匹配融合后的枚举
    if result is {
        .ErrorA.Timeout =&gt; println("Got timeout from Lib A"),
        .ErrorA.ConnectionFailed =&gt; println("Got connection failed from Lib A"),

        .ErrorB.NotFound =&gt; println("Got not found from Lib B"),
        .ErrorB.PermissionDenied =&gt; println("Got permission denied from Lib B"),

        -- 也可以用通配符匹配来自特定源的所有错误
        .ErrorA.* =&gt; println("Some other error from Lib A"),
        .ErrorB.* =&gt; println("Some other error from Lib B"),
    }

    -- 验证身份：融合后的值与原始值不同
    let original_a = ErrorA.Timeout;
    let fused_a: C = original_a.into();
    asserts original_a != fused_a;
}
</code></pre>
<ul>
<li><strong>机制</strong>: 通过一个编译时计算接收一个枚举类型列表，并在<strong>编译时生成一个新的枚举类型</strong>。</li>
<li><strong>保留来源</strong>: 生成的融合枚举不仅包含所有源枚举的变体，还<strong>保留了每个变体来自哪个源枚举的信息</strong>。这体现在访问和匹配融合枚举时，通常需要带上源枚举的名称或路径（如 <code>.ErrorA.Timeout</code>）。</li>
<li><strong>类型转换</strong>: 提供了从源枚举类型到融合枚举类型的转换方法（如 <code>.into()</code>）。</li>
<li><strong>组合性</strong>: 极大地提高了代码的组合性。不同的模块可以独立定义自己的枚举，然后在需要统一处理的地方将它们融合起来，而<strong>无需修改原始定义</strong>。</li>
<li><strong>错误处理应用</strong>: 枚举融合在错误处理 (<code>![Err1, Err2] T</code>) 中的应用最为典型。编译器自动为你执行这种融合，创建匿名的错误联合类型来无缝地处理来自不同源的错误，并能通过层级路径或通配符精确匹配。</li>
</ul>
<p><strong>层级化与融合的协同:</strong></p>
<p>这两个特性可以完美结合。如果源枚举本身就是层级化的，那么融合后的枚举也会保留这种层级结构，只是在最外层增加了一个表示来源的层级。例如，如果 <code>ErrorA</code> 有 <code>.network.timeout</code>，融合后可能匹配 <code>.ErrorA.network.timeout</code>。</p>
<p><strong>总结:</strong></p>
<p>Flurry 通过<strong>层级化枚举</strong>提供了强大的内部组织能力，使得大型枚举易于管理和理解。通过<strong>枚举融合</strong>，它又提供了无与伦比的外部组合能力，允许在不修改原始定义的情况下合并不同的枚举类型。这两个特性共同作用，特别是在构建复杂的错误类型、状态机、AST 节点等方面，提供了极大的便利性和表达力，是 Flurry 类型系统设计中的一大亮点。</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="枚举属性"><a class="header" href="#枚举属性">枚举属性</a></h1>
<div style="break-before: page; page-break-before: always;"></div><h1 id="tagged-polymorphism"><a class="header" href="#tagged-polymorphism">Tagged Polymorphism</a></h1>
<div style="break-before: page; page-break-before: always;"></div><h1 id="联合体-unions"><a class="header" href="#联合体-unions">联合体 (Unions)</a></h1>
<p>联合体（Union）是一种特殊的数据结构，它允许其多个字段<strong>共享同一块内存区域</strong>。这意味着在任何时候，联合体实例只能有效地持有其<strong>一个</strong>字段的值。联合体主要用于与 C 语言代码交互 (FFI)，或者在需要极度节省内存且能安全管理活跃字段的底层编程场景。</p>
<p><strong>警告：</strong> 使用联合体需要开发者<strong>自行承担</strong>跟踪哪个字段当前是活跃（有效）的责任。错误地访问非活跃字段可能导致未定义行为或内存损坏。因此，除非有充分理由并能确保安全，否则应优先使用枚举（Enum）来表示“多种可能之一”的数据。</p>
<p><strong>定义联合体</strong></p>
<p>使用 <code>union</code> 关键字定义联合体，并在花括号 <code>{}</code> 内声明其所有可能的字段。</p>
<pre><code class="language-flurry">-- 一个可能持有整数或浮点数的联合体
union IntOrFloat {
    i: i32,
    f: f32,
}

-- 用于模拟 C 语言联合体进行 FFI
^repr(.c) -- (假设) 指定 C 兼容布局
union CEventArgs {
    key_event: KeyEvent, -- 假设 KeyEvent 是一个 struct
    mouse_event: MouseEvent, -- 假设 MouseEvent 是一个 struct
}
</code></pre>
<p><strong>实例化和访问联合体</strong></p>
<p>联合体的实例化通常需要明确指定要初始化的那个字段。访问字段也使用点 (<code>.</code>) 操作符，但必须确保访问的是当前活跃的字段。</p>
<pre><code class="language-flurry">test {
    -- 初始化为整数
    let value = IntOrFloat { .i 10 }

    -- 安全地访问整数（因为我们知道它是活跃的）
    println("Integer value: {}", value.i);

    -- **危险操作**：写入浮点字段会覆盖整数数据
    value.f = 3.14;

    -- **危险操作**：此时再读取 i 字段会得到未定义或损坏的数据
    -- println("Integer value after float write: {}", value.i); -- &lt;-- 未定义行为!

    -- 安全地访问浮点数
    println("Float value: {}", value.f);
}
</code></pre>
<p><strong>安全使用联合体：带标签的联合体 (Tagged Unions)</strong></p>
<p>为了安全地使用联合体，常见的模式是将其与一个枚举（作为标签）组合在一个结构体中，用标签来明确指示当前哪个联合体字段是活跃的。Flurry 的<strong>枚举 (Enum)</strong> 本身就是一种更安全、更推荐的带标签联合体的实现方式。</p>
<pre><code class="language-flurry">-- 使用枚举代替裸联合体是更安全的方式
enum SafeIntOrFloat {
    integer(i32),
    float(f32),
}

test {
    let value = SafeIntOrFloat.integer(10);

    match value {
        .integer(i) =&gt; println("Integer: {}", i),
        .float(f) =&gt; println("Float: {}", f),
    }
}
</code></pre>
<p><strong>联合体作为命名空间与关联函数</strong></p>
<p>与 <code>struct</code> 和 <code>enum</code> 一样，<code>union</code> 定义也是一个命名空间，可以在其内部定义关联函数。但这通常不太常见，因为操作联合体实例需要外部信息（哪个字段是活跃的）。</p>
<p><strong>总结</strong></p>
<p>联合体提供了底层内存布局的控制能力，允许多个字段共享内存，主要用于 FFI 和特殊的内存优化场景。然而，由于其固有的不安全性（需要手动跟踪活跃字段），<strong>强烈建议优先使用枚举 (Enum)</strong> 来表示互斥的数据变体。如果必须使用联合体，务必采取额外的机制（如外部标签）来确保访问安全。</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="数组与切片-arrays--slices"><a class="header" href="#数组与切片-arrays--slices">数组与切片 (Arrays &amp; Slices)</a></h1>
<p>数组（Array）和切片（Slice）是 Flurry 中用于处理<strong>连续内存序列</strong>的核心数据结构。它们都包含相同类型的元素。</p>
<h2 id="数组-array"><a class="header" href="#数组-array">数组 (Array)</a></h2>
<p>数组是一组<strong>固定大小</strong>的、存储在<strong>栈上或作为其他数据结构一部分</strong>的同质元素序列。数组的大小是其<strong>类型</strong>的一部分。</p>
<p><strong>定义与实例化:</strong></p>
<p>数组类型通常表示为 <code>Array&lt;T, N&gt;</code>，其中 <code>T</code> 是元素类型，<code>N</code> 是数组长度（一个编译时usize）。</p>
<pre><code class="language-flurry">-- 定义一个包含 5 个 i32 的数组
let numbers: Array&lt;i32, 5&gt; = undefined; -- `undefined`不进行初始化

-- 使用字面量初始化数组
let first_primes: Array&lt;i32, 5&gt; = [2, 3, 5, 7];

-- 创建一个包含 100 个 0 的数组
let zeros: Array&lt;i8, 100&gt; = Array.fill(0);
</code></pre>
<ul>
<li>数组的大小 (<code>N</code>) 必须在编译时确定。</li>
<li>数组的所有元素在内存中是连续存储的。</li>
</ul>
<p><strong>访问元素:</strong></p>
<p>使用方括号 <code>[]</code> 和索引（从 0 开始）来访问数组元素。</p>
<pre><code class="language-flurry">let third_prime = first_primes[2]; -- 访问索引为 2 的元素 (值为 5)
println("Third prime: {}", third_prime);

let array = [10, 20, 30];
array[0] = 15; -- 修改第一个元素
</code></pre>
<p><strong>数组长度:</strong></p>
<pre><code class="language-flurry">let len = first_primes.len();
println("Length of first_primes: {}", len); -- 输出: 4
</code></pre>
<h2 id="切片-slice"><a class="header" href="#切片-slice">切片 (Slice)</a></h2>
<p>切片是对数组（或其他连续内存区域，如 <code>Vec</code> 的内部缓冲区）的一个<strong>引用或视图</strong>。切片本身<strong>不拥有</strong>数据，它只是“借用”了一段连续的元素。切片的<strong>大小在运行时确定</strong>。</p>
<p><strong>切片类型:</strong></p>
<p>切片类型通常表示为 <code>Slice&lt;T&gt;</code> 或类似的泛型类型，其中 <code>T</code> 是元素类型。一个切片实例内部通常包含一个指向序列起始元素的<strong>指针</strong>和一个<strong>长度</strong>信息。</p>
<p><strong>创建切片:</strong></p>
<p>切片通常通过对数组或其他支持切片操作的数据结构（如 <code>Vec</code>）进行“切片”操作来创建。</p>
<pre><code class="language-flurry">let array = [1, 2, 3, 4, 5];

-- 创建一个包含所有元素的切片
let full_slice: Slice&lt;i32&gt; = array[..]; -- 引用整个数组

-- 创建一个包含索引 1 到 3 (不含 3) 的元素的切片
let partial_slice: Slice&lt;i32&gt; = array[1..3]; -- 引用 [2, 3]

-- 创建从索引 2 到末尾的切片
let tail_slice: Slice&lt;i32&gt; = array[2..]; -- 引用 [3, 4, 5]

-- 创建从开始到索引 3 (不含 3) 的切片
let head_slice: Slice&lt;i32&gt; = array[..3]; -- 引用 [1, 2, 3]
</code></pre>
<p><strong>使用切片:</strong></p>
<p>切片可以像数组一样使用索引访问其元素，但边界检查是在<strong>运行时</strong>进行的。</p>
<pre><code class="language-flurry">println("First element of partial_slice: {}", partial_slice[0]); -- 输出: 2
-- partial_slice[2] -- 这会导致运行时错误 (越界)

let slice_len = partial_slice.len(); -- 获取切片长度
println("Length of partial_slice: {}", slice_len); -- 输出: 2
</code></pre>
<p>切片经常用作函数参数，以接受任何长度的同质序列，而无需知道其底层是数组还是 <code>Vec</code>。</p>
<pre><code class="language-flurry">-- 这个函数可以接受任何 i32 的切片
fn sum(numbers: Slice&lt;i32&gt;) -&gt; i32 {
    let total = 0;
    for num in numbers { -- 可以直接迭代切片
        total += num;
    }
    total
}

test {
    let arr = [1, 2, 3];
    let vec_data = Vec&lt;i32&gt;.from([4, 5, 6]); -- 假设 Vec 可以创建
    println("Sum of arr slice: {}", sum(arr[..]));       -- 传递数组切片
    println("Sum of vec slice: {}", sum(vec_data.slice())); -- 假设 Vec 提供切片方法
}
</code></pre>
<p><strong>总结</strong></p>
<p>数组是固定大小的、拥有数据的序列，而切片是动态大小的、借用数据的视图。数组的大小是类型的一部分（编译时确定），切片的大小是运行时确定的。切片提供了处理不同来源连续序列的统一、灵活的方式。</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="元组-tuples"><a class="header" href="#元组-tuples">元组 (Tuples)</a></h1>
<p>元组（Tuple）是一种简单、匿名的复合数据类型，用于将<strong>固定数量</strong>的、<strong>可能不同类型</strong>的值组合在一起。元组的大小（元素数量）和每个元素的类型在编译时确定。</p>
<p><strong>定义与实例化:</strong></p>
<p>元组使用圆括号 <code>()</code> 将其元素括起来，元素之间用逗号 <code>,</code> 分隔。元组的类型由其包含的元素类型和顺序决定。</p>
<pre><code class="language-flurry">-- 创建一个包含 i32 和 f64 的元组
let pair: (i32, f64) = (10, 3.14);

-- 类型可以省略，编译器会自动推断
let another_pair = (-5, true); -- 类型是 (i32, bool)

-- 包含不同类型的元组
let mix = (1, "hello", false, 3.0f32); -- 类型是 (i32, str, bool, f32)

-- 单元元组 (Unit Tuple) / 空元组
let empty: () = (); -- 类型是 `void`，只有一个值 ()
</code></pre>
<p><strong>访问元素 (解构与索引):</strong></p>
<p>访问元组成员主要有两种方式：</p>
<ol>
<li>
<p><strong>解构绑定 (Destructuring Bind)</strong>: 使用 <code>let</code> 和模式匹配将元组的元素直接绑定到变量。这是最常用的方式。</p>
<pre><code class="language-flurry">let (integer_part, float_part) = pair; -- 解构 pair
println("Integer: {}, Float: {}", integer_part, float_part); -- 输出: Integer: 10, Float: 3.14

let (status_code, _, message, _) = mix; -- 使用 _ 忽略不需要的元素
println("Status: {}", status_code);
</code></pre>
</li>
<li>
<p><strong>索引访问 (Index Access)</strong>: 访问特定位置的元素。</p>
<pre><code class="language-flurry">let first_element = pair[0];  -- 访问第一个元素 (10)
let second_element = pair[1]; -- 访问第二个元素 (3.14)
println("Access via index: {}, {}", first_element, second_element);
</code></pre>
</li>
</ol>
<p><strong>元组作为函数返回值:</strong></p>
<p>元组非常适合用作函数的返回值，以一次性返回多个不同类型的值。</p>
<pre><code class="language-flurry">fn divide_with_remainder(dividend: i32, divisor: i32) -&gt; (i32, i32) {
    let quotient = dividend / divisor;
    let remainder = dividend % divisor;
    (quotient, remainder) -- 返回一个包含商和余数的元组
}

test {
    let (q, r) = divide_with_remainder(10, 3);
    println("10 / 3 = {} remainder {}", q, r); -- 输出: 10 / 3 = 3 remainder 1
}
</code></pre>
<p><strong>单元类型/空类型 <code>void</code></strong>:</p>
<p>空类型 <code>void</code> 也称为单元类型 (Unit Type)。它只有一个值 <code>()</code>。当函数不返回任何有意义的信息时，通常隐式或显式地返回 <code>()</code> 类型。</p>
<p><strong>总结</strong></p>
<p>元组提供了一种轻量级的方式来组合固定数量、可能不同类型的值。它们在需要临时组合数据或从函数返回多个值时非常有用。通过解构绑定和索引访问可以方便地使用元组成员。</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="模块-modules"><a class="header" href="#模块-modules">模块 (Modules)</a></h1>
<p>在 Flurry 中，每个类型都有独立命名空间，所以都可以被视为模块。模块的成员可以是其他模块、函数、常量、类型、全局变量等。
而<code>mod</code>类型则是专门用于表示模块的类型。每个文件都是一个模块，每个目录也是一个模块，其内容由目录下的<code>mod.fl</code>文件定义。</p>
<p><strong>模块定义:</strong></p>
<p>模块使用 <code>mod</code> 关键字定义，通常与文件系统结构相关联（例如，一个目录对应一个模块，<code>mod.fl</code> 作为入口文件）。</p>
<pre><code class="language-flurry">-- src/utils/mod.fl
mod string; -- 使用 'mod' 语句引入同目录下的 string.fl
mod math;   -- 引入 math.fl

pub fn helper_function() { {- ... -} }

const VERSION = "1.0";

-- src/utils/string.fl
pub fn trim(s: String) -&gt; String { {- ... -} }

-- src/utils/math.fl
pub fn add(a: i32, b: i32) -&gt; i32 { a + b }

-- --- main.fl ---
mod utils; -- 引入 src/utils/ 目录下的模块

test {
    -- 像访问类型成员一样访问模块成员
    let version = utils.VERSION;
    utils.helper_function();
    let sum = utils.math.add(1, 2);
    let trimmed = utils.string.trim(" hello ".to_string());
}
</code></pre>
<p><strong>总结</strong></p>
<p>Flurry 将模块提升到了与 <code>struct</code>, <code>enum</code> 等类似的“类型”地位，使其成为编译时可知、可包含各种成员的命名空间实体。这种设计统一了成员访问语法，并为强大的编译时元编程能力（如模块反射）奠定了基础。</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="newtypes"><a class="header" href="#newtypes">Newtypes</a></h1>
<p>Newtype 是一种创建新类型的方式，该新类型在底层表示上基于一个已存在的类型，但在类型系统层面被视为一个<strong>完全不同</strong>的类型。它主要用于增强类型安全，通过创建独特的类型来区分原本表示相同但逻辑意义不同的值。</p>
<p><strong>定义 Newtype</strong></p>
<p>使用 <code>newtype</code> 关键字来定义。</p>
<pre><code class="language-flurry">-- 定义一个 Newtype UserId，底层是 Uuid
newtype UserId = Uuid;
-- 自动derive From&lt;Uuid&gt; for Uuid，derive Into&lt;Uuid&gt; for UserId

-- 定义一个 Newtype EmailAddress，底层是 String
newtype EmailAddress = String;

-- 也可以基于复杂类型
struct ProductId { value: u64 }
newtype ProductRef = *ProductId;
</code></pre>
<p><strong>类型安全优势</strong></p>
<p>Newtype 的核心价值在于类型安全。即使底层表示相同，不同 Newtype 之间也不能直接混用。</p>
<pre><code class="language-flurry">fn process_user(id: UserId) { {- ... -} }
fn process_product(id: ProductId) { {- ... -} } -- 假设 ProductId 是一个 struct

test {
    let user_uuid = Uuid.new_v4();
    let product_id_val = 12345u64;

    let user_id = user_uuid.into();
    let product_id = ProductId { .value product_id_val }

    process_user(user_id); -- OK

    -- process_user(user_uuid); -- 错误! 类型不匹配 (Uuid vs UserId)
    -- process_user(product_id); -- 错误! 类型不匹配 (ProductId vs UserId)
    -- let temp_id = product_id_val.into();
}
</code></pre>
<p><strong>底层表示与开销</strong></p>
<p>Newtype 通常是<strong>零成本抽象 (zero-cost abstraction)</strong>。在编译后，Newtype 与其底层类型在内存表示和运行时行为上通常是<strong>完全相同</strong>的。类型检查只发生在编译时。这意味着使用 Newtype 不会带来额外的运行时性能开销。</p>
<p><strong>为 Newtype 实现 Trait 或方法</strong></p>
<p>可以像为普通 <code>struct</code> 或 <code>enum</code> 一样，为 Newtype 定义implementation和extension。
定义newtype时，不仅编译器会自动为其实现 <code>From</code> 和 <code>Into</code> trait，还可以通过type casting 来实现类型转换。</p>
<pre><code class="language-flurry">newtype Age = u32;

impl Age {
    -- 为 Newtype 添加方法
    pub fn is_adult(*self) -&gt; bool {
        self.as(u32) &gt;= 18
    }
}

extend fmt.Display for Age {
    fn fmt(*self, f: *fmt.Formatter) -&gt; fmt.Result {
        -- 需要访问底层值
        write!(f, "{} years old", self.as(u32))
    }
}

test {
    let age = 30.as(Age);
    if age.is_adult() {
        println("Is adult. {}", age); -- 输出: Is adult. 30 years old
    }
}
</code></pre>
<p><strong>Typealias vs Newtype</strong>
Newtype 与类型别名（<code>typealias</code>）的区别在于，类型别名只是给现有类型一个新的名字，而 Newtype 创建了一个新的、独立的类型。类型别名不会提供额外的类型安全，而 Newtype 则会。</p>
<p><strong>总结</strong></p>
<p>Newtype 提供了一种轻量级（通常零成本）的方式来创建新的、类型安全的别名。它们是增强代码清晰度和防止逻辑错误的有力工具，通过在编译时区分不同逻辑含义但底层表示可能相同的值。当你想给一个现有类型赋予更强的语义约束时，Newtype 是一个绝佳的选择。</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="模式匹配-pattern-matching"><a class="header" href="#模式匹配-pattern-matching">模式匹配 (Pattern Matching)</a></h1>
<p>模式匹配是 Flurry 语言中一种强大且富有表现力的机制，用于检查一个值是否符合某种结构，并在此过程中可能将值的组成部分解构 (destructure) 并绑定到新的变量上。它不仅可以用于解构复杂的数据结构，还与控制流语句深度集成，提供了简洁、安全的条件判断和循环方式。</p>
<p>Flurry 的模式语法极其丰富，涵盖了从基本字面量到复杂数据结构、范围、组合模式等多种形式。</p>
<p>本章将涵盖：</p>
<ul>
<li><strong>模式语法</strong>: 详细介绍 Flurry 支持的各种模式类型及其语法。</li>
<li><strong>匹配控制流</strong>: 展示模式匹配如何在 <code>match</code> 表达式、<code>if is</code> 语句和 <code>while is</code> 循环中驱动程序逻辑。</li>
</ul>
<p>理解模式匹配是掌握 Flurry 表达力和编写惯用 (idiomatic) Flurry 代码的关键。</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="模式语法-pattern-syntax"><a class="header" href="#模式语法-pattern-syntax">模式语法 (Pattern Syntax)</a></h1>
<p>模式 (Pattern) 是 Flurry 中用于匹配值的语法结构。以下是 Flurry 支持的主要模式类型：</p>
<p><strong>1. 基本模式 (Basic Patterns)</strong></p>
<p>这些是最简单的模式，用于匹配字面量或进行简单的绑定/忽略。</p>
<ul>
<li><strong>字面量模式 (Literal Patterns)</strong>: 直接匹配整数、浮点数、字符、字符串、布尔值或 <code>null</code>。
<pre><code class="language-flurry">if value is {
    0 =&gt; println("Zero"),
    'a' =&gt; println("The character 'a'"),
    "hello" =&gt; println("Got hello"),
    true =&gt; println("It's true"),
    null =&gt; println("It's null"),
    _ =&gt; println("Something else"), -- 通配符模式
}
</code></pre>
</li>
<li><strong>标识符模式 (Identifier Pattern) / 变量绑定</strong>: 匹配任何值，并将其绑定到一个新的变量上。该变量在匹配分支的作用域内可用。
<pre><code class="language-flurry">if some_option is {
    data? =&gt; println("Got data: {}", data), -- data 绑定了 some 内部的值
    null =&gt; println("No data"),
}
</code></pre>
</li>
<li><strong>通配符模式 (<code>_</code>)</strong>: 匹配任何值，但不将其绑定到变量。用于忽略不关心的值或部分结构。
<pre><code class="language-flurry">let (x, _, z) = (1, 2, 3); -- 忽略元组的第二个元素
</code></pre>
</li>
<li><strong>符号模式 (<code>.symbol</code>)</strong>: 匹配特定的符号字面量。常用于匹配枚举变体或<code>Symbol</code>类型。
<pre><code class="language-flurry">if status is {
    .ok =&gt; println("Status is Ok"),
    .error =&gt; println("An error occurred"),
    -- ...
}
</code></pre>
</li>
</ul>
<p><strong>2. 容器模式 (Container Patterns)</strong></p>
<p>用于解构和匹配复合数据结构。</p>
<ul>
<li><strong>列表/数组/切片模式 (<code>[pattern1, pattern2, ...]</code>)</strong>: 匹配列表、数组或切片。
<ul>
<li>可以匹配固定长度：<code>[first, second]</code></li>
<li>可以使用 <code>...rest_binding</code> 捕获剩余元素（Rest Pattern）：<code>[head, ...tail]</code></li>
<li>可以匹配空列表：<code>[]</code></li>
</ul>
<pre><code class="language-flurry">if items is {
    [] =&gt; println("Empty list"),
    [one] =&gt; println("One item: {}", one),
    [first, second, ...rest] =&gt; println("First: {}, Second: {}, Rest: {any}", first, second, rest),
    -- ...
}
</code></pre>
</li>
<li><strong>元组模式 (<code>(pattern1, pattern2, ...)</code>)</strong>: 按位置解构元组。
<pre><code class="language-flurry">let (id, name, _) = get_user_info(); -- 解构元组，忽略第三个元素
</code></pre>
</li>
<li><strong>记录/结构体模式 (<code>{ field1: pattern1, field2, ... }</code>)</strong>: 按字段名解构结构体或 <code>object</code>。
<ul>
<li><code>field: pattern</code>: 将字段 <code>field</code> 的值与 <code>pattern</code> 匹配。</li>
<li><code>field</code>: 字段名简写，等同于 <code>field: field</code>，即将字段值绑定到同名变量。</li>
<li><code>...</code>: （可能支持）用于表示匹配剩余字段，但通常结构体匹配是精确的或显式忽略。</li>
</ul>
<pre><code class="language-flurry">struct Point { x: i32, y: i32 }
let p = Point { .x 10, .y 20 }
if p is {
    -- 使用字段名简写和显式模式
    { x: 0, y } =&gt; println("On Y axis at {}", y),
    { x, y: 0 } =&gt; println("On X axis at {}", x),
    { x, y }    =&gt; println("Point at ({}, {})", x, y),
}
</code></pre>
</li>
</ul>
<p><strong>3. 调用模式 (Call Patterns)</strong></p>
<p>用于匹配枚举变体或构造器调用的结果，常用于解构带有数据的枚举。</p>
<ul>
<li><strong>圆括号调用模式 (<code>pattern (pattern1, ...)</code> 或 <code>pattern (pattern1, ...)</code>?)</strong>: 匹配特定的枚举变体（带有关联数据）、代数效应调用。
<pre><code class="language-flurry">enum Message { quit, write(String), move { x: i32, y: i32 } }
if msg is {
    -- 匹配不带数据的变体
    .quit =&gt; println("Quit message"),
    -- 匹配 Write 变体，并将内部 String 绑定到 text
    .write(text) =&gt; println("Write: {}", text),
    -- 匹配 Move 变体，并使用记录模式解构其关联数据
    .move { x, y: 0 } =&gt; println("Move on X axis to {}", x),
    .move { x, y } =&gt; println("Move to ({}, {})", x, y),
}
</code></pre>
</li>
<li><strong>尖括号调用模式 (<code>pattern&lt;...&gt;(...)</code> 或 <code>pattern&lt;...&gt;(...)</code>)</strong>: 用于匹配带有泛型参数的代数效应调用、类型表达式。</li>
<li><strong>花括号调用模式 (<code>pattern{...}</code> 或 <code>pattern{...}</code>):</strong> 用于匹配使用记录语法的变体或构造器（如上例中的 <code>move</code>）。</li>
</ul>
<p><strong>4. 范围模式 (Range Patterns)</strong></p>
<p>用于匹配数值或字符是否落在某个范围内。</p>
<ul>
<li><strong>开区间上限 (<code>..end</code>)</strong>: 匹配小于 <code>end</code> 的值。（之前讨论过，可能需要确认语法）</li>
<li><strong>闭区间 (<code>start..=end</code>)</strong>: 匹配大于等于 <code>start</code> 且小于等于 <code>end</code> 的值。</li>
<li><strong>开区间 (<code>start..end</code>)</strong>: 匹配大于等于 <code>start</code> 且小于 <code>end</code> 的值。</li>
<li><strong>闭区间下限 (<code>start..</code>)</strong>: 匹配大于等于 <code>start</code> 的值。
<pre><code class="language-flurry">if value is {
    0..=9 =&gt; println("Single digit"),
    10..=99 =&gt; println("Two digits"),
    100.. =&gt; println("Three or more digits"),
    ..0 =&gt; println("Negative or zero? Check exact rules"), -- 语法和含义需确认
}
if character is {
    'a'..='z' =&gt; println("Lowercase letter"),
    'A'..='Z' =&gt; println("Uppercase letter"),
    _ =&gt; println("Not a letter"),
}
</code></pre>
</li>
</ul>
<p><strong>5. 组合模式 (Combination Patterns)</strong></p>
<p>允许将多个模式组合起来。</p>
<ul>
<li><strong>或模式 (<code>pattern1 or pattern2</code>)</strong>: 如果值匹配 <code>pattern1</code> <strong>或</strong> <code>pattern2</code>，则匹配成功。用于合并相似的分支。
<pre><code class="language-flurry">if character is {
    'a' or 'e' or 'i' or 'o' or 'u' =&gt; println("Lowercase vowel"),
    'A' or 'E' or 'I' or 'O' or 'U' =&gt; println("Uppercase vowel"),
    _ =&gt; println("Consonant or other"),
}
</code></pre>
<strong>注意</strong>: 在 <code>or</code> 模式中，所有分支绑定的变量必须<strong>名称和类型都相同</strong>，或者只使用 <code>_</code> 忽略。</li>
<li><strong>与模式 (<code>pattern1 and expr is pattern2</code>)</strong>: 如果值匹配 <code>pattern1</code>，并且 <code>expr</code> 的值匹配 <code>pattern2</code>，则匹配成功。用于在模式中嵌套其他表达式。
<pre><code class="language-flurry">-- 选课逻辑展示
fn select_course(student: Student, course: Course) {
	if student is { class_id: class_id? }
		and get_class(class_id) is class?
		and get_major(class.major_id) is major?
		if course.satified(major) {
		println("选课成功")
	}
}
</code></pre>
</li>
</ul>
<p><strong>6. 绑定模式 (<code>pattern as identifier</code>)</strong></p>
<p>在匹配 <code>pattern</code> 的同时，将<strong>整个匹配到的值</strong>（未解构的）绑定到一个新的变量 <code>identifier</code> 上。</p>
<pre><code class="language-flurry">if message is {
    -- 匹配 move 变体，解构 x，并将整个 move 变体绑定到 m
    .move { x: 10, y } as msg =&gt; {
        println("Move to x=10 at y={}", y);
        process_move_message(msg); -- 使用绑定的整个消息 msg
    }
    -- ... 其他分支
}
</code></pre>
<p><strong>7. 条件守卫模式 (<code>pattern if condition_expr</code>)</strong></p>
<p>只有当值匹配 <code>pattern</code> <strong>并且</strong> <code>condition_expr</code>（一个运行时布尔表达式）求值为 <code>true</code> 时，模式才算匹配成功。<code>condition_expr</code> 可以使用 <code>pattern</code> 中绑定的变量。</p>
<pre><code class="language-flurry">if maybe_point is {
    { x, y }? if x == y =&gt; { -- 匹配结构体 Point
        println("Point on diagonal: ({}, {})", x, y);
    },
    { x, y }? =&gt; { -- 其他结构体情况
        println("Point not on diagonal: ({}, {})", x, y);
    }
    _ =&gt; println("Not a point"),
}
</code></pre>
<p><strong>8. 其他模式</strong></p>
<ul>
<li><strong>可选模式 (<code>pattern?</code>)</strong>: 用于匹配可空类型的非空部分，并解构其内部值。（如 <code>if opt is data? { ... }</code>）</li>
<li><strong>正确模式</strong>: 用于匹配结果类型的成功部分，并解构其内部值。（如 <code>if result is data! { ... }</code>）</li>
<li><strong>错误模式</strong>: 用于匹配结果类型的错误部分，并解构其内部值。（如 <code>if result is error err { ... }</code>）</li>
<li><strong>表达式模式 (<code>&lt;expr&gt;</code>)</strong>: 将编译时表达式 <code>expr</code> 的求值结果作为模式进行匹配。</li>
<li><strong>位向量模式 (<code>0x(...)</code>, <code>0o(...)</code>, <code>0b(...)</code>)</strong>: 匹配和解构位向量字面量。</li>
<li><strong>字符串前缀模式 (<code>"prefix" ++ rest_binding</code>)</strong>: 匹配以特定前缀开头的字符串。</li>
<li><strong>否定模式 (<code>not pattern</code>)</strong>: 匹配不符合 <code>pattern</code> 的值。</li>
<li><strong>类型绑定模式 (<code>'id</code>)</strong>: 用于匹配类型表达式，为了方便起见，类型模式中的id通常会被解析为表达式，因此变量绑定需要新的语法，如<code>Array&lt;'T, 128&gt;</code>。</li>
</ul>
<p>Flurry 提供了极为丰富和灵活的模式语法，为数据检查、解构和控制流提供了强大的支持。</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="匹配控制流-matching-control-flow"><a class="header" href="#匹配控制流-matching-control-flow">匹配控制流 (Matching Control Flow)</a></h1>
<p>模式匹配不仅限于解构数据，它还深度集成到 Flurry 的控制流语句中，提供了比传统条件判断更强大、更安全的流程控制方式。主要体现在 <code>match</code> 表达式、<code>if is</code> 语句和 <code>while is</code> 循环中。</p>
<h2 id="match-表达式"><a class="header" href="#match-表达式"><code>match</code> 表达式</a></h2>
<p><code>match</code> 表达式是 Flurry 中进行模式匹配的核心结构。它接收一个表达式的值，然后按顺序尝试将其与一系列模式进行匹配。一旦找到第一个成功匹配的模式，就会执行该模式对应的代码块，并且 <code>match</code> 表达式本身会返回该代码块的求值结果。</p>
<p><strong>基本语法:</strong></p>
<pre><code class="language-flurry">&lt;value_expr&gt; match {
    &lt;pattern_1&gt; =&gt; &lt;result_expr_1&gt;,
    &lt;pattern_2&gt; =&gt; &lt;result_expr_2&gt;,
    -- ... more branches
    &lt;pattern_n&gt; =&gt; &lt;result_expr_n&gt;,
    -- 可以提供一个通配符或变量绑定来确保穷尽性
    _ =&gt; &lt;default_result_expr&gt;,
}
</code></pre>
<ul>
<li><code>&lt;value_expr&gt;</code>: 需要被匹配的值。</li>
<li><code>&lt;pattern_i&gt; =&gt; &lt;result_expr_i&gt;</code>: 一个匹配分支，由模式和对应的结果表达式（或代码块）组成。</li>
<li><code>match</code> 按顺序尝试匹配 <code>&lt;pattern_i&gt;</code>。第一个成功匹配的分支会被选中。</li>
<li>模式中绑定的变量在对应的 <code>&lt;result_expr_i&gt;</code> 中可用。</li>
<li><strong>穷尽性 (Exhaustiveness)</strong>: Flurry 编译器通常会检查 <code>match</code> 表达式的分支是否覆盖了 <code>&lt;value_expr&gt;</code> 类型的所有可能情况。如果不是穷尽的，并且没有通配符 <code>_</code> 或变量绑定分支来处理剩余情况，编译器会报错，以防止运行时遗漏某些情况。</li>
<li><strong>返回值</strong>: <code>match</code> 作为一个表达式，其本身会有一个值，即被选中分支的 <code>&lt;result_expr_i&gt;</code> 的值。所有分支的结果表达式必须具有兼容的类型。</li>
</ul>
<p><strong>示例:</strong></p>
<pre><code class="language-flurry">enum Message { ping, pong, text(String) }

fn process_message(msg: Message) -&gt; String {
    let response = msg match {
        .ping =&gt; "Pong response".to_string(),
        .pong =&gt; "Ping response".to_string(),
        .text(content) if content.len() &gt; 10 =&gt; { -- 使用模式守卫
            println("Received long text: {}", content);
            "Text OK (long)".to_string()
        },
        .Textextt(content) =&gt; {
            println("Received short text: {}", content);
            "Text OK (short)".to_string()
        } -- 这个 match 是穷尽的，覆盖了所有 Message 变体
    }
    response
}
</code></pre>
<h2 id="if-is-语句"><a class="header" href="#if-is-语句"><code>if is</code> 语句</a></h2>
<p><code>if is</code> 语句不仅可以可以像match一样匹配多个分支，还提供了一种简洁的方式来检查一个值是否匹配<strong>单个</strong>模式，并在匹配成功时执行一个代码块。
<strong>基本语法:</strong></p>
<pre><code class="language-flurry">if &lt;value_expr&gt; is &lt;pattern&gt; {
    -- Code to execute if value_expr matches pattern
    -- pattern 中绑定的变量在此可用
} else if &lt;value_expr&gt; is &lt;another_pattern&gt; { -- 可选 else if is
    -- ...
} else { -- 可选 else
    -- Code to execute if no preceding pattern matched
}
</code></pre>
<ul>
<li>它尝试将 <code>&lt;value_expr&gt;</code> 与 <code>&lt;pattern&gt;</code> 匹配。</li>
<li>如果匹配成功，执行第一个 <code>{...}</code> 块，并且模式中绑定的变量在该块内可用。</li>
<li>可以链式地使用 <code>else if is</code> 来检查其他模式。</li>
<li>可选的 <code>else</code> 块处理所有前面模式都不匹配的情况。</li>
</ul>
<p><strong>示例 (处理可选类型):</strong></p>
<pre><code class="language-flurry">fn print_optional(opt: ?i32) {
    if opt is some? { -- 使用可选模式 '?'
        println("Value is: {}", some); -- 'some' 自动绑定内部值
    } else {
        println("Value is None/null.");
    }
}

print_optional(Some(10)); -- 输出: Value is: 10
print_optional(None);     -- 输出: Value is None/null.
</code></pre>
<p><strong>对比 <code>match</code> 与 <code>if is</code></strong>:</p>
<ul>
<li><code>match</code>为后缀风格，适合在复杂链式表达式中使用。</li>
<li>当只关心是否匹配一两种特定模式时，<code>if is</code> 通常更简洁。</li>
</ul>
<h2 id="while-is-循环"><a class="header" href="#while-is-循环"><code>while is</code> 循环</a></h2>
<p><code>while is</code> 循环将模式匹配与 <code>while</code> 循环结合，允许在循环的每次迭代开始时对一个表达式的值进行模式匹配。只有当匹配成功时，循环体才会执行，并且模式绑定的变量可在循环体中使用。</p>
<p><strong>基本语法:</strong></p>
<pre><code class="language-flurry">while &lt;value_expr&gt; is &lt;pattern&gt; {
    -- Loop body, executed if value_expr matches pattern
    -- pattern 中绑定的变量在此可用
}
</code></pre>
<ul>
<li>在每次循环迭代前，求值 <code>&lt;value_expr&gt;</code> 并尝试与 <code>&lt;pattern&gt;</code> 匹配。</li>
<li>如果匹配成功，执行循环体。</li>
<li>如果匹配失败，循环终止。</li>
</ul>
<p><strong>示例 (处理迭代器返回可选类型):</strong></p>
<pre><code class="language-flurry">let some_iterator = create_iterator();

while some_iterator.next() is item? {
    process_item(item);
}

println("Iterator finished.");
</code></pre>
<p><code>while is</code> 对于消耗迭代器、处理消息队列或其他在循环中需要检查并解构值的场景非常方便和安全。</p>
<p><strong>总结</strong></p>
<p>Flurry 将模式匹配与核心控制流结构（<code>match</code>, <code>if is</code>, <code>while is</code>）深度集成，提供了一种强大、安全且表达力强的方式来根据数据的结构和值来引导程序流程。穷尽性检查（主要在 <code>match</code> 中）进一步增强了代码的健壮性。</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="trait-与多态-traits--polymorphism"><a class="header" href="#trait-与多态-traits--polymorphism">Trait 与多态 (Traits &amp; Polymorphism)</a></h1>
<p>Trait 是 Flurry 中定义共享行为的主要方式。它们类似于其他语言中的接口 (Interfaces) 或协议 (Protocols)，允许你定义一组方法签名，然后不同的类型可以实现这些方法。Trait 是 Flurry 实现抽象、代码复用以及多态性的核心机制。</p>
<p>多态性（Polymorphism）指的是代码可以处理多种不同类型的值的能力。Flurry trait系统主要通过以下方式支持多态：</p>
<ul>
<li><strong>静态分派 (Static Dispatch)</strong>: 基于泛型和 Trait 约束，在编译时确定调用哪个具体实现。</li>
<li><strong>动态分派 (Dynamic Dispatch)</strong>: 在运行时根据对象的实际类型确定调用哪个实现，Flurry 提供了两种主要的动态多态机制。</li>
</ul>
<p>本章将深入探讨：</p>
<ul>
<li>Trait 的定义与实现 (<code>trait</code>, <code>impl</code>, <code>derive</code>)，以及孤儿原则。</li>
<li>独特的 <code>extend</code> 机制，用于作用域受限的行为扩展和字面量拓展。</li>
<li>Flurry 支持的动态多态方式：传统的 Trait Object (<code>dyn Trait</code>) 与基于枚举的 Tagged Polymorphism。</li>
<li>使用 <code>using</code> 实现组合与接口委托。</li>
</ul>
<p>理解 Trait 和多态机制对于编写可扩展、可维护和抽象良好的 Flurry 代码至关重要。</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="trait-定义与实现-impl-derive"><a class="header" href="#trait-定义与实现-impl-derive">Trait 定义与实现 (impl, derive)</a></h1>
<p>Trait 用于定义一组类型可以共享的方法签名。它描述了某种抽象行为或能力，而不涉及具体的实现。</p>
<p><strong>定义 Trait</strong></p>
<p>使用 <code>trait</code> 关键字定义一个 Trait，并在其花括号 <code>{}</code> 内声明方法签名。方法签名指定了方法名、参数（包括 <code>self</code> 参数）和返回类型，但没有具体实现。</p>
<pre><code class="language-flurry">-- 定义一个描述可被绘制行为的 Trait
trait Drawable {
    -- 方法签名，需要一个不可变引用指向实例
    fn draw(*self, canvas: *Canvas);
}

-- 定义一个可以计算面积的 Trait
trait Area {
    fn area(*self) -&gt; f64;
}

-- Trait 也可以包含关联类型或常量 (如果 Flurry 支持)
trait Container {
    -- type Item; -- (假设) 关联类型
    -- const DEFAULT_CAPACITY: usize; -- (假设) 关联常量
    fn add(*mut self, item: Item); -- 使用关联类型
}
</code></pre>
<p><strong>实现 Trait (<code>impl</code>)</strong></p>
<p>要让一个具体类型（如 <code>struct</code> 或 <code>enum</code>）拥有 Trait 定义的行为，你需要为该类型<strong>实现 (implement)</strong> 这个 Trait。使用 <code>impl TraitName for TypeName</code> 语法，并在花括号内提供 Trait 中必要方法的具体实现。</p>
<pre><code class="language-flurry">struct Circle { radius: f64 }
struct Rectangle { width: f64, height: f64 }

-- 为 Circle 实现 Area Trait
impl Area for Circle {
    fn area(*self) -&gt; f64 {
        3.1415926535 * self.radius * self.radius
    }
}

-- 为 Rectangle 实现 Area Trait
impl Area for Rectangle {
    fn area(*self) -&gt; f64 {
        self.width * self.height
    }
}

-- (假设 Drawable 和 Canvas 已定义)
impl Drawable for Circle {
    fn draw(*self, canvas: *Canvas) {
        -- ... 具体绘制圆形的逻辑 ...
        println("Drawing a circle with radius {}", self.radius);
    }
}

impl Drawable for Rectangle {
    fn draw(*self, canvas: *Canvas) {
        -- ... 具体绘制矩形的逻辑 ...
        println("Drawing a rectangle {}x{}", self.width, self.height);
    }
}

test {
    let c = Circle { .radius 5.0 }
    let r = Rectangle { .width 4.0, .height 6.0 }

    println("Circle area: {}", c.area());   -- 调用 Circle 的 area 实现
    println("Rectangle area: {}", r.area()); -- 调用 Rectangle 的 area 实现
}
</code></pre>
<p><strong>孤儿原则 (Orphan Rule)</strong></p>
<p>为了保证全局实现的一致性，Flurry（类似 Rust）遵循<strong>孤儿原则</strong>：</p>
<blockquote>
<p>对于一个 Trait <code>T</code> 和一个类型 <code>Type</code>，<code>impl T for Type</code> 这个实现必须定义在<strong>定义 <code>T</code> 的那个包</strong>中，或者定义在<strong>定义 <code>Type</code> 的那个包</strong>中。不允许在完全独立的第三方包中为外部定义的 Trait 和外部定义的 Type 提供实现。</p>
</blockquote>
<p>这个规则确保了任何 <code>impl</code> 都有一个明确的“负责人”，防止不同的库对同一对 Trait/Type 提供冲突的实现。</p>
<p><strong>自动派生 (<code>derive</code>)</strong></p>
<p>对于一些常见的、具有标准实现模式的 Trait（例如，用于调试输出的 <code>Debug</code>、用于比较的 <code>Eq</code>/<code>Ord</code>、用于复制的 <code>Copy</code>/<code>Clone</code> 等），Flurry 可能提供 <code>derive</code> 属性，让编译器自动为你的类型生成这些 Trait 的实现代码。</p>
<pre><code class="language-flurry">struct Point {
    x: i32,
    y: i32,
}

derive Debug, Clone, Copy for Point;

test {
    let p1 = Point { .x 1, .y 2 }
    let p2 = p1.clone();
    println("Debug point: {debug}", p2);
}
</code></pre>
<p><code>derive</code> 大大减少了编写样板实现代码的工作量。可派生的 Trait 通常由语言或标准库预定义。</p>
<p>Trait 和 <code>impl</code> 构成了 Flurry 静态抽象和代码共享的基础。通过它们，你可以编写泛型代码，约束泛型参数必须实现特定的 Trait，从而在编译时实现类型安全的多态。</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="扩展-extension-与字面量拓展"><a class="header" href="#扩展-extension-与字面量拓展">扩展 (extension) 与字面量拓展</a></h1>
<p>虽然孤儿原则对于维护大型项目的一致性至关重要，但在某些情况下，我们可能希望<strong>临时性地</strong>或者在<strong>受限的作用域内</strong>为一个类型添加某个 Trait 的行为，即使这违反了孤儿原则。Flurry 提供了 <code>extend</code> 关键字来实现这种受控的扩展。</p>
<p><code>extend</code> 机制还巧妙地被用作 Flurry <strong>字面量拓展</strong>的基础。</p>
<p><strong><code>extend</code> 关键字</strong></p>
<p><code>extend Trait for Type</code> 语法允许你在任何作用域内为一个（可能是外部定义的）类型 <code>Type</code> 提供一个（可能是外部定义的） <code>Trait</code> 的实现。</p>
<pre><code class="language-flurry">mod external_lib {
    pub trait Printer {
        fn print_info(*self);
    }
    pub struct Data { pub value: i32 }
}

mod my_code {
    use external_lib.{ Printer, Data }

    -- 在 my_code 模块内，为外部类型 Data 实现外部 Trait Printer
    -- 这违反了孤儿原则，但 extend 允许这样做
    extend Printer for Data {
        fn print_info(*self) {
            println!("My custom print for Data: value = {}", self.value);
        }
    }

    pub fn process_data(d: Data) {
        -- 在这个作用域内，调用 print_info 会使用上面的 extend 实现
        d.print_info();
    }
}

mod another_code {
     use external_lib.{ Printer, Data }
     -- 在这个模块，Printer for Data 的 extend 没有被导入，
     -- 所以无法调用 d.print_info() (除非 external_lib 本身提供了 impl)
     pub fn process_data_again(d: Data) {
         -- d.print_info(); -- 编译错误 (假设 external_lib 无 impl)
         println("Processing data without custom print.");
     }
}
</code></pre>
<p><strong><code>extend</code> 的关键特性:</strong></p>
<ol>
<li>
<p><strong>绕过孤儿原则</strong>: 允许在任何地方定义实现。</p>
</li>
<li>
<p><strong>作用域限制</strong>: <code>extend</code> 定义的实现<strong>仅在其被定义的词法作用域内有效</strong>。外部代码默认不受此影响。</p>
</li>
<li>
<p><strong>遮盖 (Shadowing)</strong>: 如果在同一个作用域内，同时存在一个类型的常规 <code>impl</code> 和一个 <code>extend</code> 实现，那么**<code>extend</code> 的实现会优先被使用**，它会“遮盖”住 <code>impl</code> 的实现。</p>
</li>
<li>
<p><strong>可命名与导入</strong>: 可以将 <code>extend</code> 块赋予一个常量标识符，然后其他模块可以通过 <code>use</code> 显式导入这个命名扩展，从而将该扩展实现引入到自己的作用域中。</p>
<pre><code class="language-flurry">mod extensions {
    use external_lib.{ Printer, Data }
    -- 将扩展命名为 PrettyPrinterForData
    pub const PrettyPrinterForData = extend Printer for Data {
         fn print_info(*self) {
             println!("*** Pretty Data: {} ***", self.value);
         }
    }
}

mod user_code {
    use external_lib.Data;
    use extensions.PrettyPrinterForData; -- 显式导入扩展

    pub fn main() {
        let d = Data { .value 42 }
        -- 因为导入了扩展，这里会使用 PrettyPrinterForData 的实现
        d.print_info(); -- 输出: *** Pretty Data: 42 ***
    }
}
</code></pre>
<p>这种显式导入机制提供了精确的作用域控制。</p>
</li>
</ol>
<p><strong><code>extend</code> 用于字面量拓展</strong></p>
<p>Flurry 利用 <code>extend</code> 机制实现了一种强大且统一的<strong>字面量拓展</strong>功能。当你编写类似 <code>10px</code> 或 <code>"hello"c</code> 的代码时，编译器实际上是在查找一个为该字面量对应的内置类型（如 <code>Integer</code>, <code>u32</code>, <code>str</code>）定义的、包含名为 <code>px</code> 或 <code>c</code> 的方法的 <code>extend</code> 块。</p>
<p><strong>原理:</strong></p>
<p><code>literal + identifier</code> 形式会被编译器尝试解析为 <code>literal.identifier()</code> 的方法调用。这个方法必须由一个在当前作用域内有效的 <code>extend</code> 块提供。</p>
<pre><code class="language-flurry">-- 为内置类型 u32 扩展一个 px 方法
extend u32 {
    -- 'px' 方法接收 u32 值，返回 Pixel 类型
    comptime fn px(self) -&gt; Pixel {
        Pixel { .value self } -- 假设 Pixel struct 已定义
    }
}

-- 为内置 str 类型扩展一个 cstr 方法
extend str {
    -- 'cstr' 方法接收编译时 str，返回某种 C 兼容字符串表示
    comptime fn cstr(self) -&gt; CString { -- 假设 CString 类型存在
        -- ... 编译时或运行时逻辑来创建 CString ...
        CString.from_str_with_null(self)
    }
}

test {
    let length = 100px; -- 等价于 (100).px()
    asserts length.value == 100;

    let c_string = "api_key"cstr; -- 等价于 ("api_key").cstr()
    -- c_string 现在是一个 CString 实例
}
</code></pre>
<ul>
<li>这个机制允许开发者或库为基础类型添加与领域相关的单位或转换，使代码更具表现力。</li>
<li>语言可以内置一些常用的拓展，如 <code>"..."cstr</code> 用于 FFI，<code>"..."bytes</code> 用于创建字节序列。</li>
<li>这些 <code>extend</code> 实现同样遵循作用域规则，可以被局部定义或通过 <code>use</code> 导入。</li>
</ul>
<p><strong>总结</strong></p>
<p><code>extend</code> 是 Flurry 提供的一种受控方式，用于在标准 <code>impl</code> 和孤儿原则之外为类型添加行为。它的作用域限制和显式导入机制避免了全局冲突，同时为局部行为定制和实现优雅的字面量拓展提供了强大的支持。使用 <code>extend</code> 时需要注意其作用域和对代码可读性的潜在影响。</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="动态多态-dyn-trait-vs-tagged_polymorphic"><a class="header" href="#动态多态-dyn-trait-vs-tagged_polymorphic">动态多态 (<code>dyn Trait</code> vs <code>tagged_polymorphic</code>)</a></h1>
<p>动态多态允许在运行时根据对象的实际类型来决定调用哪个方法实现。这对于处理异构集合、实现回调或插件系统等场景非常有用。Flurry 提供了两种主要的动态多态机制，它们各有优劣，适用于不同的场景。</p>
<h2 id="1-trait-object-dyn-trait"><a class="header" href="#1-trait-object-dyn-trait">1. Trait Object (<code>dyn Trait</code>)</a></h2>
<p>Trait Object 是实现动态多态的标准、开放的方式，类似于 Rust 的 <code>dyn Trait</code> 或 C++ 的虚函数机制（通过指针或引用）。</p>
<p><strong>概念:</strong></p>
<ul>
<li>一个 <code>dyn TraitName</code> 类型的值是一个<strong>胖指针 (fat pointer)</strong>。它包含两部分：
<ol>
<li>一个指向实际对象数据的指针。</li>
<li>一个指向该对象类型为 <code>TraitName</code> 实现的<strong>虚函数表 (vtable)</strong> 或等效结构（如接口表 itable）的指针。</li>
</ol>
</li>
<li>vtable 包含了一系列函数指针，指向该类型为 Trait 定义的每个方法的具体实现。</li>
</ul>
<p><strong>用法:</strong></p>
<p>你可以创建一个 <code>dyn Trait</code> 类型胖指针，它可以在运行时指向任何实现了该 Trait 的类型的实例。</p>
<pre><code class="language-flurry">trait Speaker {
    fn speak(*self);
}

struct Dog { name: String }
impl Speaker for Dog {
    fn speak(*self) { println!("{} says Woof!", self.name); }
}

struct Cat { name: String }
impl Speaker for Cat {
    fn speak(*self) { println!("{} says Meow!", self.name); }
}

test {
    let dog = Dog { .name "Buddy".to_string() }
    let cat = Cat { .name "Whiskers".to_string() }

    -- 创建 Trait Object (通过 Box 指针)
    let animals: Vec&lt;dyn Speaker&gt; = Vec.new();
    animals.push(Box.new(dog).*.dyn(Speaker));
    animals.push(Box.new(cat).*.dyn(Speaker));

    -- 动态调用方法
    for animal in animals.iter() {
        -- animal 是 dyn Speaker 类型
        -- 调用 speak 时，会通过 vtable 查找并执行 Dog 或 Cat 的实现
        animal.speak();
    }
    -- 输出:
    -- Buddy says Woof!
    -- Whiskers says Meow!
}

-- 作为函数参数
fn make_speak(speaker: dyn Speaker) {
    speaker.speak(); -- 动态分派
}
</code></pre>
<p><strong>优点:</strong></p>
<ul>
<li><strong>开放集合 (Open Set)</strong>: 任何类型，在任何地方（遵守孤儿原则或使用 <code>extend</code>），只要实现了 <code>TraitName</code>，就可以在运行时被视为 <code>dyn TraitName</code>。库可以定义 Trait，使用者可以自由实现并传递给库，扩展性极好。</li>
<li><strong>解耦</strong>: 调用者只需要知道 <code>dyn Trait</code> 接口，无需关心具体实现类型。</li>
</ul>
<p><strong>缺点:</strong></p>
<ul>
<li><strong>运行时开销</strong>:
<ul>
<li><strong>间接调用</strong>: 方法调用需要通过 vtable 进行间接查找，比静态分派慢。</li>
<li><strong>无法内联</strong>: 编译器无法内联 <code>dyn Trait</code> 的方法调用。</li>
<li><strong>胖指针开销</strong>: <code>dyn Trait</code> 指针（或引用）本身比普通指针占用更多空间（通常是两倍）。</li>
</ul>
</li>
<li><strong>类型信息部分丢失</strong>: 在 <code>dyn Trait</code> 上下文中，对象的具体类型信息在编译时丢失了（虽然运行时可以通过 RTTI 查询，但通常不鼓励）。</li>
</ul>
<h2 id="2-tagged-polymorphism-基于枚举的半自动多态"><a class="header" href="#2-tagged-polymorphism-基于枚举的半自动多态">2. Tagged Polymorphism (基于枚举的半自动多态)</a></h2>
<p>Flurry 提供了一种替代的、基于标签枚举的动态多态机制，通过在 <code>enum</code> 定义上使用 <code>.tagged_polymorphic TraitName</code> 属性来启用。</p>
<p><strong>概念:</strong></p>
<ul>
<li><strong>载体</strong>: 一个枚举（标记为 <code>.dst true</code> 和 <code>.tagged_polymorphic TraitName</code>）包含所有需要参与此多态的<strong>固定</strong>类型集合作为其变体。</li>
<li><strong>实现</strong>: 每个枚举变体对应的具体类型（如 <code>Dog</code>, <code>Cat</code>）必须<strong>分别</strong>实现目标 Trait (<code>Speaker</code>)。</li>
<li><strong>分派</strong>: 当通过枚举实例（通常是指针 <code>*EnumName</code> 或 <code>Box&lt;EnumName&gt;</code>）调用 Trait 方法时，分派逻辑<strong>基于枚举的内部标签 (tag)</strong>。编译器（或运行时）检查标签，确定当前是哪个变体，然后<strong>直接调用</strong>该变体类型对应的 Trait 实现。这通常通过编译时生成的 <code>match</code>/<code>switch</code> 或跳转表完成。</li>
</ul>
<p><strong>用法:</strong></p>
<pre><code class="language-flurry">trait Greeter {
    fn greet(*self) -&gt; String;
}

struct EnglishGreeter {}
impl Greeter for EnglishGreeter { fn greet(*self) -&gt; String { "Hello!".to_string() } }

struct SpanishGreeter {}
impl Greeter for SpanishGreeter { fn greet(*self) -&gt; String { "¡Hola!".to_string() } }

-- 定义 Tagged Polymorphic 枚举
enum AnyGreeter {
    .dst true, -- 表明是动态大小
    .tagged_polymorphic Greeter, -- 启用基于标签的多态，目标 Trait 是 Greeter

    english: EnglishGreeter, -- 包含具体类型作为变体
    spanish: SpanishGreeter,
}

test {
    -- 创建实例 (需要通过指针或 Box)
    let greeter1 = Box.new(AnyGreeter.english(EnglishGreeter {}));
    let greeter2 = Box.new(AnyGreeter.spanish(SpanishGreeter {}));

    let greeters: Vec&lt;Box&lt;AnyGreeter&gt;&gt; = Vec.new();
    greeters.push(greeter1);
    greeters.push(greeter2);

    for g in greeters.iter() {
        -- 调用 greet 方法。分派基于 g 指向的 AnyGreeter 实例的 tag
        println!("{}", g.greet());
    }
    -- 输出:
    -- Hello!
    -- ¡Hola!
}

-- 作为函数参数 (注意类型是具体的枚举指针)
fn perform_greeting(g: *AnyGreeter) {
    println!("{}", g.greet()); -- 基于 tag 分派
}
</code></pre>
<p><strong>优点:</strong></p>
<ul>
<li><strong>潜在性能优势</strong>:
<ul>
<li>分派后通常是<strong>直接调用</strong>，避免了 vtable 的间接性。</li>
</ul>
<ul>
<li><strong>无 vptr 开销</strong>: 对象本身不存储额外的 vptr。</li>
</ul>
<ul>
<li>分支预测可能更友好。</li>
</ul>
</li>
<li><strong>类型信息保留</strong>: 运行时可以轻易检查枚举 tag，获知具体变体类型。</li>
</ul>
<p><strong>缺点:</strong></p>
<ul>
<li><strong>封闭集合 (Closed Set)</strong>: 最大的限制。所有需要参与多态的类型<strong>必须预先在枚举中定义</strong>。无法在枚举之外添加新的实现类型。</li>
<li><strong>修改不便</strong>: 添加新类型需要修改枚举定义。</li>
<li><strong>适用性</strong>: 主要适用于类型集合已知且稳定的场景。</li>
</ul>
<p><strong><code>comptime</code> 的作用</strong>: Flurry 强大的 <code>comptime</code> 能力可以缓解封闭集合的问题。库可以提供 <code>comptime</code> 元函数，允许使用者在编译时<strong>动态生成</strong>一个包含他们所需类型列表的 <code>tagged_polymorphic</code> 枚举，从而在终点代码中获得性能优势，而库本身接口可能仍然使用 <code>dyn Trait</code>。</p>
<p><strong>总结: 何时选择？</strong></p>
<ul>
<li><strong>库接口 / 开放扩展性</strong>: 优先选择 <strong><code>dyn Trait</code></strong>。它提供了必要的灵活性和解耦。</li>
<li><strong>性能关键 / 类型集合固定</strong>: 在应用程序内部或性能瓶颈处，如果涉及的类型集合是已知的、有限的，可以考虑使用 <strong><code>tagged_polymorphic</code> 枚举</strong>以获得潜在的性能提升和更明确的类型信息。</li>
<li><strong>编译时定制</strong>: 结合 <code>comptime</code>，可以在编译时生成定制的 <code>tagged_polymorphic</code> 枚举，为特定场景提供优化。</li>
</ul>
<p>Flurry 同时提供这两种机制，让开发者可以根据具体需求在开放性和性能/类型精确性之间做出权衡。</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="组合与委托-using"><a class="header" href="#组合与委托-using">组合与委托 (<code>using</code>)</a></h1>
<p>面向对象编程中，通常推荐“组合优于继承”。组合是指一个类型通过包含其他类型的实例来复用其功能。然而，简单组合后，外部类型需要手动编写大量的“转发”或“委托”方法才能将内部对象的功能暴露出来。</p>
<p>Flurry 提供了 <code>using</code> 关键字，作为一种便捷的语法糖，用于将结构体内部字段的<strong>公开 (public)</strong> 成员（方法和可能的字段）自动“提升”或“委托”到外部结构体的接口上。</p>
<p><strong>基本语法:</strong></p>
<p>在 <code>struct</code> 定义内部使用：</p>
<pre><code class="language-flurry">using &lt;field_name&gt;.*;
</code></pre>
<ul>
<li><code>&lt;field_name&gt;</code>: 必须是当前结构体的一个字段。</li>
<li><code>.*</code>: 表示将该字段类型的所有<strong>公开</strong>成员引入到当前结构体的接口中。</li>
</ul>
<p><strong>示例:</strong></p>
<pre><code class="language-flurry">struct Engine {
    horsepower: u32,
    pub fn start(*self) { println("Engine started!"); {- ... -} }
    pub fn stop(*self) { println("Engine stopped."); {- ... -} }
}

struct Transmission {
    gear_count: u8,
    pub fn shift_up(*self) { {- ... -} println("Shifted up."); }
    pub fn shift_down(*self) { {- ... -} println("Shifted down."); }
}

struct Car {
    engine: Engine,
    transmission: Transmission,
    color: String,

    -- 将 engine 的所有 pub 方法 (start, stop) 引入 Car 的接口
    using engine.*;
    -- 将 transmission 的所有 pub 方法 (shift_up, shift_down) 引入 Car 的接口
    using transmission.*;

    -- Car 也可以有自己的方法
    pub fn drive(*self) {
        self.start(); -- 直接调用来自 Engine 的 start 方法
        println("Driving a {} car.", self.color);
    }
}

test {
    let my_car = Car {
        .engine Engine { .horsepower 200 },
        .transmission Transmission { .gear_count 6 },
        .color "Red".to_string(),
    }

    my_car.drive();      -- 调用 Car 自己的方法，内部调用了 engine.start()
    my_car.shift_up();   -- 直接调用来自 Transmission 的方法
    my_car.stop();       -- 直接调用来自 Engine 的方法
}
-- 可能输出:
-- Engine started!
-- Driving a Red car.
-- Shifted up.
-- Engine stopped.
</code></pre>
<p><strong>工作机制:</strong></p>
<p><code>using field.*</code> 并不实际复制成员。它更像是在编译时为外部结构体自动生成了转发方法（对于方法）或代理访问（对于字段，如果字段也是 pub 的话）。当调用 <code>my_car.start()</code> 时，编译器知道 <code>start</code> 来自 <code>engine</code> 字段，并生成调用 <code>my_car.engine.start()</code> 的代码。</p>
<p><strong>优点:</strong></p>
<ul>
<li><strong>减少样板代码</strong>: 极大地简化了将内部组件功能暴露给外部的过程。</li>
<li><strong>促进组合</strong>: 使基于组合的设计模式更加易于实现和使用。</li>
<li><strong>接口清晰 (某种程度上)</strong>: 调用点的代码更简洁。</li>
</ul>
<p><strong>注意事项与潜在问题:</strong></p>
<ul>
<li><strong>命名冲突</strong>: 如果 <code>using</code> 了多个字段，并且它们导出的成员有同名，或者外部结构体本身定义了同名成员，Flurry编译器将会报错并拒绝编译。解决方法是使用 <code>using field.{member1, member2}</code> 语法来选择性导出成员，或者使用不同的名称。</li>
<li><strong>可读性</strong>: 调用者可能需要查看结构体定义中的 <code>using</code> 语句才能确定某个方法或字段的实际来源。IDE 的支持对于缓解这个问题很重要。</li>
<li><strong>选择性导出</strong>: 语法 <code>using field.*</code> 导出了所有公开成员。flurry还支持更精细的控制，例如 <code>using field.{member1, method2}</code>, 这可以减少不必要的接口暴露和命名冲突。</li>
<li><strong>访问权限</strong>: <code>using</code> 只导出源字段类型的<strong>公开 (public)</strong> 成员。</li>
</ul>
<p><strong>总结</strong></p>
<p><code>using</code> 关键字是 Flurry 提供的一种简化组合模式的有效工具。它通过自动委托内部对象的公开成员，减少了样板代码，使得基于组合的设计更加便捷。在使用时，需要注意潜在的命名冲突和对代码可读性的影响，并依赖语言清晰的规则来管理这些问题。</p>
<div style="break-before: page; page-break-before: always;"></div><h2 id="编译时计算-comptime"><a class="header" href="#编译时计算-comptime">编译时计算 (<code>comptime</code>)</a></h2>
<p>Flurry 的一个核心且强大的特性是<strong>编译时计算 (Compile-Time Computation)</strong>，通常以关键字 <code>comptime</code> 体现。该机制允许开发者在编译阶段执行代码，从而实现高级别的元编程、优化和类型安全保证。</p>
<p><strong>Flurry 的两级计算模型</strong></p>
<p>理解 <code>comptime</code> 的基础在于认识 Flurry 的<strong>两级计算模型 (Two-Level Computation Model)</strong>，该模型明确区分了两个不同的执行阶段：</p>
<ol>
<li><strong>编译时 (Comptime)</strong>: 编译器工作的阶段。在此阶段，Flurry 不仅执行传统的编译任务（如语法分析、类型检查、代码生成），还提供了一个功能强大的<strong>编译时运行时 (Comptime Runtime)</strong>，用于执行标记为 <code>comptime</code> 的代码。</li>
<li><strong>运行时 (Runtime)</strong>: 编译产物（即可执行程序）被最终用户执行的阶段。</li>
</ol>
<p>这种设计使得许多传统上必须在运行时完成的操作得以在编译时执行。其主要优势包括：实现零成本抽象、提升运行时性能、增强类型安全以及提供强大的元编程能力。</p>
<p><strong>编译时与运行时上下文的区分</strong></p>
<p>准确识别代码执行的上下文至关重要：</p>
<ul>
<li><strong>运行时上下文 (Runtime Context)</strong>:
<ul>
<li>常规函数（未使用 <code>comptime</code> 标记的 <code>fn</code>）的函数体内部。</li>
<li>传递给常规函数的运行时参数的值。</li>
</ul>
</li>
<li><strong>编译时上下文 (Comptime Context)</strong>:
<ul>
<li><strong>所有类型表达式 (<code>Type</code>) 和 Trait 表达式</strong>: 类型和 Trait 在 Flurry 中是一等公民，它们在编译时被定义、操作和求值。</li>
<li><strong>所有属性 (<code>.</code> 或 <code>^</code>)</strong>: 附加到类型、函数、字段等的属性，其求值发生在编译时。</li>
<li><strong>顶级命名空间 (Top-level Namespace) 中的定义</strong>: 全局作用域下的声明（如 <code>const</code>, <code>fn</code>, <code>struct</code> 定义）通常在编译时处理。</li>
<li><strong>常量 (<code>const</code>) 的初始化表达式</strong>: <code>const</code> 声明要求其值必须在编译时确定。</li>
<li><strong><code>comptime</code> 函数的参数和函数体</strong>: 标记为 <code>comptime</code> 的函数及其参数完全在编译时处理和执行。</li>
<li><strong>常规函数的 <code>comptime</code> 参数</strong>: 常规函数可以接收 <code>comptime</code> 参数，这些参数的值在编译时确定并传入。</li>
<li><strong>特定的语法结构</strong>: 某些语法结构，如 <code>pattern_from_expr</code> 中的 <code>&lt;expr&gt;</code> 部分、结构体字段的默认值表达式等，要求其表达式必须是编译时可求值的。</li>
<li><strong><code>inline</code> 控制流结构的条件/控制部分</strong>: 对于 <code>inline if</code>, <code>inline for</code>, <code>inline when</code> 等结构，其<strong>条件表达式</strong>或<strong>迭代控制逻辑</strong>在编译时求值。其<strong>内部代码块</strong>的执行上下文（编译时或运行时）则取决于 <code>inline</code> 结构自身所处的上下文。</li>
</ul>
</li>
</ul>
<p><strong>Flurry 结构：作为编译时值的语言构件</strong></p>
<p>一个核心概念是：在 Flurry 的编译时环境中，许多语言的基本构件——例如<strong>结构体定义 (<code>struct</code>)、函数定义 (<code>fn</code>)、枚举定义 (<code>enum</code>)、Trait 定义 (<code>trait</code>)</strong> 等——本身被视为<strong>编译时值 (comptime values)</strong>。</p>
<p>这意味着这些定义不仅是声明，更是可以在编译时被操作和传递的数据。</p>
<p>示例：</p>
<pre><code class="language-flurry">const Student = struct {
    name: String,
    age: u8,
}

-- greet: pure comptime fn&lt;T:- ToString&gt; -&gt; fn(T) -&gt; String,
-- 可简写为 for&lt;T:- ToString&gt; fn(T) -&gt; String
fn greet(name: T) -&gt; String where T:- ToString {
    "Hello, " + name.to_string()
}

</code></pre>
<p>Flurry 可能还提供更底层的编译时 API，用于以编程方式构建这些语言构件：</p>
<pre><code class="language-flurry">-- 使用假设的编译时 API 动态构建结构体类型
let DynamicStruct = Type.Struct.new(
    .fields = { -- 一个编译时 object (异构映射)
        .id    { .type Uuid }, -- 字段名和类型
        .value { .type str, .default "empty" }, -- 包含默认值
    }
);
-- 在编译时对生成的类型进行内省 (Introspection)
let fields = Type.Struct.fields(DynamicStruct); -- 获取字段信息
assert(fields[1].get(.name, String)? == "value"); -- 安全地获取字段名
assert(fields[1].get(.default, String)? == "empty"); -- 安全地获取默认值
</code></pre>
<p>这种将语言构件视为编译时值的范式，使 <code>comptime</code> 超越了简单的常量折叠，成为一个强大的<strong>类型和代码生成引擎</strong>。</p>
<p><strong>编译时类型系统的特性：依赖类型与渐进类型</strong></p>
<p>Flurry 的编译时类型系统具备两个关键特性，增强了其表达能力和灵活性：</p>
<ol>
<li>
<p><strong>依赖类型 (Dependent Types)</strong>: 函数（或其他接受参数的结构）的<strong>后续参数类型</strong>可以<strong>依赖于先前 <code>comptime</code> 参数的值</strong>。这允许创建高度灵活且类型安全的接口。<code>println</code> 函数是典型的例子，其可变参数 <code>varargs</code> 的具体类型由 <code>comptime</code> 参数 <code>format</code> 字符串的值在编译时确定。</p>
<pre><code class="language-flurry">-- varargs的类型是一个元组，从fmt.Parse(format)求值而出
fn println(comptime format: str, ...varargs: fmt.Parse(format)) {
    ...
    inline for v in varargs {
        const T = v'type;
        inline when {
            T: str =&gt; stdio.write_all(v),
            T:- Display =&gt; stdio.write_all(c.to_string().as_str()),
            T: usize =&gt; stdio.write_all(fmt.format_int(v)),
            ...
        }
    }
}
</code></pre>
</li>
<li>
<p><strong>渐进类型 (Gradual Typing)</strong>: 编译时的容器类型，如 <code>object</code>（异构键值对）和 <code>List&lt;Any&gt;</code>（异构列表），允许存储<strong>不同类型的值</strong>。Flurry 提供了渐进类型的访问机制来处理这种异构性：</p>
<ul>
<li><strong>类型安全的获取 (<code>.get(key, ExpectedType: Type) -&gt; ?ExpectedType</code>)</strong>: 尝试获取指定键且类型为 <code>ExpectedType</code> 的值。</li>
</ul>
<pre><code class="language-flurry">    let config = { .port 8080, .host "localhost", .enable_tls true } -- 编译时 object

    -- 类型安全获取
    let port: ?i32 = config.get(.port, i32);
    assert(port? == 8080);
    let host: ?String = config.get(.host, String);
    assert(host? == "localhost");
    let timeout: ?u64 = config.get(.timeout, u64);
    assert(timeout == null);
</code></pre>
<p>渐进类型为编译时处理结构未知或异构的数据提供了必要的灵活性。</p>
</li>
</ol>
<p><strong>编译时与运行时的交互机制</strong></p>
<p>尽管编译时和运行时是不同的阶段，Flurry 提供了明确的机制允许它们交互：</p>
<ul>
<li>
<p><strong>沉降 (Lowering)</strong>: 指将<strong>编译时可知的值</strong>作为常量嵌入到运行时代码中作为运行时值的过程。这通常是隐式发生的。例如，在运行时代码 <code>let x = 10;</code> 中，字面量 <code>10</code> 是一个编译时整数值，被沉降为运行时的整数值。</p>
</li>
<li>
<p><strong><code>comptime { ... }</code> 块</strong>: 允许在<strong>运行时上下文</strong>中嵌入一段需要在<strong>编译时</strong>执行的代码。此代码块通常用于计算一个编译时值，该值随后可以通过沉降被外围的运行时代码使用。</p>
<pre><code class="language-flurry">fn get_platform_info() -&gt; String {
    -- os_name 在此被沉降为运行时字符串常量
    let os_name: str = inline if build.target.os == .linux {
        "Linux" -- 编译时字符串
    } else if build.target.os == .windows {
        "Windows" -- 编译时字符串
    } else {
        "Unknown OS" -- 编译时字符串
    }

    fmt.format("Running on: {}", os_name)
}
</code></pre>
</li>
<li>
<p><strong><code>inline</code> 控制流 (<code>inline if</code>/<code>when</code>/<code>for</code>/<code>match</code>)</strong>: 这些是关键的<strong>编译时控制流</strong>结构。它们根据编译时条件或数据，在编译阶段选择性地生成、省略或重复代码片段。</p>
<ul>
<li><code>inline if</code>/<code>when</code>: 用于条件编译，根据编译时布尔表达式或类型匹配决定包含哪个代码分支。</li>
<li><code>inline for</code>: 用于编译时循环展开（例如，遍历编译时已知的数组或元组）或根据编译时集合生成代码。</li>
</ul>
</li>
</ul>
<p><strong>总结：<code>comptime</code> 的核心价值</strong></p>
<p>Flurry 的 <code>comptime</code> 机制提供了一个功能完备的编译时编程环境，其核心特征包括：</p>
<ul>
<li><strong>两级计算模型</strong>: 清晰分离编译时与运行时。</li>
<li><strong>语言构件作为编译时值</strong>: 类型、函数等可在编译时被操作。</li>
<li><strong>依赖类型与渐进类型</strong>: 增强了编译时类型系统的表达力和灵活性。</li>
<li><strong>编译时控制流 (<code>inline</code>)</strong>: 实现代码生成和特化。</li>
<li><strong>类型谓词</strong>: 提供强大的编译时约束能力。</li>
</ul>
<p>通过 <code>comptime</code>，Flurry 实现了：</p>
<ul>
<li><strong>零成本抽象</strong>: 高级编程构造在编译时被解析和优化，不引入运行时开销。</li>
<li><strong>强大的元编程能力</strong>: 支持在编译阶段生成代码、构建类型、处理配置等。</li>
<li><strong>增强的类型安全</strong>: 允许在编译时执行更深入的检查（例如，格式化字符串的类型安全验证）。</li>
<li><strong>潜在的性能优化</strong>: 通过编译时特化、常量计算和代码生成，可以产出高度优化的运行时代码。</li>
</ul>
<p>掌握 <code>comptime</code> 是充分利用 Flurry 语言潜力的关键，它为开发者提供了在编译阶段深度塑造程序结构和行为的能力。</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="类型谓词--精确约束与静态断言-type-predicates-precise-constraints-and-static-assertions"><a class="header" href="#类型谓词--精确约束与静态断言-type-predicates-precise-constraints-and-static-assertions">类型谓词 —— 精确约束与静态断言 (Type Predicates: Precise Constraints and Static Assertions)</a></h1>
<p>在深入探讨了 Flurry 强大的编译时计算能力之后，我们现在将目光投向其类型系统的另一个核心支柱：<strong>类型谓词 (Type Predicates)</strong>。类型谓词是可在编译时求值的逻辑命题，它们极大地增强了 Flurry 类型系统的表达能力，允许开发者对类型、值、编译时环境乃至程序行为施加精确的约束和静态断言。这些谓词是实现高级泛型、条件编译、编译时反射以及与形式化验证集成的基石。</p>
<p><strong>类型谓词语法概览 (Type Predicate Grammar Overview)</strong></p>
<p>Flurry 提供了一套丰富的语法来构造类型谓词，其核心构成要素包括但不限于：</p>
<ul>
<li><strong>类型归属 (Typing)</strong>: <code>t : T</code>
<ul>
<li>断言项 <code>t</code>（通常是一个编译时表达式或变量）的类型为 <code>T</code>。</li>
</ul>
</li>
<li><strong>Trait 约束 (Trait Bounds)</strong>: <code>(t | T) :- A</code>
<ul>
<li>断言项 <code>t</code> 或类型 <code>T</code> 实现了 Trait <code>A</code>。</li>
<li>支持复合 Trait 约束：
<ul>
<li><code>T :- A + B</code>: <code>T</code> 同时实现 <code>A</code> 和 <code>B</code>。</li>
<li><code>T :- ?A</code>: <code>T</code> 可能实现 <code>A</code>，因为有一些trait是默认实现的。</li>
<li><code>T :- not A</code>: <code>T</code> <strong>没有</strong>实现 <code>A</code>。</li>
</ul>
</li>
</ul>
</li>
<li><strong>声明约束 (Declaration Bounds)</strong>: <code>T :: t : U</code> 或 <code>T :: static t : U</code>
<ul>
<li>断言类型 <code>T</code> 内部包含一个名为 <code>t</code> 的符号，其类型为 <code>U</code>。这用于访问类型的关联类型、常量、函数、全局变量等。</li>
</ul>
</li>
<li><strong>成员约束 (Field/Method Bounds)</strong>: <code>e :~ t : A</code>
<ul>
<li>断言表达式 <code>e</code> 的类型具有一个名为 <code>t</code> 的字段或方法，其类型签名符合 <code>A</code>（通常是一个函数类型或字段类型）。</li>
</ul>
</li>
<li><strong>子类型关系 (Subtyping)</strong>: <code>T &lt;: U</code>
<ul>
<li>断言类型 <code>T</code> 是类型 <code>U</code> 的子类型（如果 Flurry 支持结构化子类型或名义子类型）。</li>
</ul>
</li>
<li><strong>类型匹配 (Type Matching)</strong>: <code>T matches W</code>
<ul>
<li>断言类型 <code>T</code> 的结构匹配模式 <code>W</code>。<code>W</code> 可以包含类型变量、通配符 (<code>any</code>)、存在量化 (<code>forall&lt;...&gt;</code>) 或其他类型构造，用于解构和匹配复杂类型结构。</li>
</ul>
</li>
<li><strong>类型相等 (Type Equality)</strong>: <code>T == U</code>
<ul>
<li>断言类型 <code>T</code> 与类型 <code>U</code> 等价。</li>
</ul>
</li>
<li><strong>逻辑连接词 (Logical Connectives)</strong>:
<ul>
<li><code>not p</code>: 逻辑非。</li>
<li><code>p and q</code>: 逻辑与。</li>
<li><code>p or q</code>: 逻辑或。</li>
<li><code>p ==&gt; q</code>: 逻辑蕴含。</li>
</ul>
</li>
</ul>
<p>这些谓词构件可以组合使用，形成复杂的编译时逻辑表达式，用于精确地描述对泛型参数、函数行为或编译环境的期望。</p>
<p><strong><code>where</code> 子句：约束的载体</strong></p>
<p>类型谓词的一个重要应用场景是**<code>where</code> 子句**。<code>where</code> 子句可以附加到多种需要约束其参数或行为的语言结构上，例如：</p>
<ul>
<li>泛型函数 (<code>fn ... where ...</code>)</li>
<li>泛型结构体/枚举/Trait 定义 (<code>struct S where T</code>, <code>enum E where T</code>, <code>trait Tr where T</code>)</li>
<li><code>impl</code> 块 (<code>impl Trait for Type where ...</code>)</li>
<li><code>extend</code> 块 (<code>extend Trait for Type where ...</code>)</li>
<li><code>derive</code> 语句 (<code>derive Trait for Type where ...</code>)</li>
</ul>
<p><code>where</code> 子句包含一个或多个由逗号分隔或逻辑连接词连接的类型谓词。</p>
<p><strong><code>requires</code> 与 <code>ensures</code>：断言的角色</strong></p>
<p>在 <code>where</code> 子句中，可以使用 <code>requires</code> 和 <code>ensures</code> 关键字来进一步明确谓词的角色（尽管简单的谓词可以直接写出）：</p>
<ul>
<li><strong><code>requires p</code></strong>: 表明谓词 <code>p</code> 是一个<strong>前置条件 (Precondition)</strong> 或<strong>约束 (Constraint)</strong>。对于其所约束的结构（我们称之为<strong>受束者 (Subject)</strong>，例如一个函数、一个 <code>impl</code> 块或一个 <code>derive</code>），<strong><code>requires</code> 谓词必须在编译时被满足，该受束者才被认为是可用的或有效的</strong>。</li>
<li><strong><code>ensures p</code></strong>: 表明谓词 <code>p</code> 是一个<strong>后置条件 (Postcondition)</strong> 或<strong>保证 (Guarantee)</strong>。它描述了如果满足前置条件，受束者成功完成后其状态或结果应该满足的属性。</li>
</ul>
<p><strong><code>requires</code> 的核心作用：可用性控制</strong></p>
<p><code>requires</code> 谓词在 Flurry 的编译时系统中扮演着至关重要的角色，它直接决定了受束结构的<strong>可用性</strong>：</p>
<ul>
<li><strong>对于函数</strong>: 如果一个泛型函数的 <code>where</code> 子句包含 <code>requires P</code>，那么只有当为该函数提供的编译时参数（如类型参数）使得谓词 <code>P</code> 为真时，该函数的这个特化版本才能被成功编译和调用。如果 <code>P</code> 不满足，将导致编译时错误，指出约束不满足。</li>
<li><strong>对于 <code>impl</code> / <code>extend</code> 块</strong>: 如果 <code>impl Trait for Type where requires P</code>，那么只有当 <code>P</code> 满足时，这个实现才会被编译器认为是有效的，并且 <code>Type</code> 的实例才能通过该 Trait 进行方法调用。否则，编译器会认为该类型没有（或在此上下文中没有）实现该 Trait。这对于实现<strong>特化 (Specialization)</strong> 或<strong>条件实现 (Conditional Implementation)</strong> 非常关键。</li>
<li><strong>对于 <code>derive</code> 语句</strong>: 如果 <code>derive Trait for Type where requires P</code>，那么只有当 <code>Type</code> 满足 <code>P</code> 时，编译器才会尝试为 <code>Type</code> 自动派生 <code>Trait</code> 的实现。这允许派生逻辑根据类型的特性进行调整。</li>
</ul>
<p><strong>示例:</strong></p>
<pre><code class="language-flurry">-- 仅当 T 未实现 Debug 时，此 impl 才可用
impl Debug for Vec&lt;T&gt;
    where requires not (T:- Debug)
{
    -- ... 手动实现 ...
}

-- 仅当 T 实现了 Debug 时，此 derive 才生效
derive Debug for Vec&lt;T&gt;
    where requires T:- Debug

-- 仅当编译时特性 "ast_dump_to_lisp" 启用时，此 impl 才可用
impl Display for Ast
    where requires build.package.features.get("ast_dump_to_lisp", bool) matches true?

-- 仅当 T 是 String 或 str，或者 T 实现了 Display 时，此函数才可用
fn println(stream: S, data: T) -&gt; !WriteErr void
    where T, S:- io.Write,
        requires T == String or T == str or T:- Display
{ {- ... -} }
</code></pre>
<p>在这些示例中，<code>requires</code> 子句充当了编译时的<strong>守卫 (Guard)</strong>，确保只有在满足特定条件时，相关的代码或实现才会被启用或认为是合法的。这种机制使得 Flurry 能够进行高度精确和上下文相关的编译时决策。</p>
<p><strong>类型谓词的应用场景</strong></p>
<p>类型谓词的强大能力使其应用广泛：</p>
<ol>
<li><strong>高级泛型编程</strong>: 实现比简单 Trait 约束更复杂的泛型约束，例如要求类型具有特定的关联类型、静态成员或特定的结构（通过 <code>matches</code>）。</li>
<li><strong>条件编译</strong>: 基于类型属性、编译时配置 (<code>build.mode</code>, <code>build.target</code>) 或特性标志 (<code>build.package.features</code>) 来条件性地包含或排除代码、实现或派生。</li>
<li><strong>特化 (Specialization)</strong>: 为泛型结构提供基于类型谓词的特化实现，以获得更好的性能或针对特定类型提供不同的行为。</li>
<li><strong>静态反射与元编程</strong>: 在 <code>comptime</code> 代码中查询类型的属性（例如，<code>if T:- Copy { ... }</code>）并据此生成代码。</li>
<li><strong>形式化规范与验证</strong>: 使用 <code>requires</code> 和 <code>ensures</code> 来编写形式化的函数契约，并作为与后续形式化验证工具交互的基础。</li>
</ol>
<p><strong>未来展望：与类型推导和 Occurrence Typing 的结合</strong></p>
<p>类型谓词系统与 Flurry 的其他高级特性（如类型推导和 Occurrence Typing）相结合，将带来更大的潜力。例如：</p>
<ul>
<li><strong>推导与检查</strong>: 类型谓词约束可以给类型提供更多信息，甚至是引入smt求解器来验证谓词的可满足性。编译器可以在编译时检查这些谓词，并在必要时生成错误或警告。</li>
<li><strong>Occurrence Typing</strong>: 在代码的不同分支中，编译器可能会根据控制流（例如，<code>inline if x is SomeType { ... }</code>）推断出变量更精确的类型或属性。这些推断出的信息可以用于在局部范围内满足更严格的类型谓词，从而允许调用在外部不可用的特化函数或实现。</li>
</ul>
<p>这种结合将使得 Flurry 的静态分析能力更加强大，能够在编译时捕捉更细微的错误，并根据代码的实际执行路径启用更精确的优化和行为。</p>
<p><strong>总结</strong></p>
<p>Flurry 的类型谓词系统是其强大编译时能力和类型系统灵活性的重要体现。通过丰富的谓词语法和 <code>where</code> 子句（特别是 <code>requires</code>），开发者可以对代码施加精确的编译时约束，实现高级泛型、条件编译、特化和静态断言。<code>requires</code> 谓词作为可用性的守卫，确保了代码在满足特定条件时才被启用。该系统不仅增强了代码的健壮性和表达力，也为未来与形式化验证的深度集成奠定了坚实的基础。理解和运用类型谓词，对于掌握 Flurry 的精髓至关重要。</p>
<div style="break-before: page; page-break-before: always;"></div><h2 id="代数效应--结构化的控制流与副作用管理-algebraic-effects-structured-control-flow-and-effect-management"><a class="header" href="#代数效应--结构化的控制流与副作用管理-algebraic-effects-structured-control-flow-and-effect-management">代数效应 —— 结构化的控制流与副作用管理 (Algebraic Effects: Structured Control Flow and Effect Management)</a></h2>
<p>在掌握了 Flurry 强大的编译时计算和精确的类型谓词之后，我们将探索 Flurry 用于处理程序动态行为——特别是<strong>副作用 (Side Effects)</strong> 和<strong>非局部控制流 (Non-local Control Flow)</strong>——的核心机制：<strong>代数效应 (Algebraic Effects)</strong>。代数效应提供了一种比传统异常处理、状态传递或 Monad 更具结构化、更灵活且更可组合的方式来管理程序的计算效应。</p>
<p><strong>1. 概念定义：请求与处理的分离</strong></p>
<p>让我们从核心概念开始。在 Flurry 中，可以将代数效应理解为一种<strong>请求-响应模型</strong>，但作用于函数调用栈之间：</p>
<ul>
<li><strong>请求 (Request / Effect Operation)</strong>: 当一个被调用函数 (Callee) 执行到一个需要外部“帮助”或需要改变常规控制流的点时（例如，需要进行 I/O、读取/修改共享状态、抛出可恢复错误、实现协程等），它<strong>并不直接执行</strong>这个操作。相反，它<strong>发出</strong> 一个<strong>效应 (Effect) 调用</strong>。这个效应本质上是一个带有参数的“请求”，表明它需要某种特定的操作或决策。</li>
<li><strong>处理 (Handling)</strong>: 这个发出的效应会沿着<strong>调用栈向上传播</strong>，直到遇到一个为该效应安装的<strong>效应处理器 (Effect Handler)</strong>。</li>
<li><strong>决策权转移</strong>: 处理器<strong>拦截</strong>这个效应，并根据效应的类型和参数<strong>决定如何响应</strong>。处理器拥有完全的控制权，它可以：
<ul>
<li>执行请求的操作（例如，实际执行 I/O）。</li>
<li>修改请求的参数。</li>
<li>向 Callee 返回一个值。</li>
<li>完全改变控制流（例如，不恢复 Callee 的执行，而是直接返回到更高层的调用者，类似异常）。</li>
<li>甚至多次恢复 Callee 的执行（用于实现协程、生成器等）。</li>
</ul>
</li>
<li><strong>关注点分离</strong>: 这种机制完美地实现了<strong>关注点分离</strong>。执行计算的函数 (Callee) 只需关心在何时需要何种效应（发出请求），而<strong>不必关心效应如何被实现</strong>。效应的具体实现（如何执行 I/O、如何管理状态、如何处理错误）则由调用者 (Caller) 通过安装不同的处理器来灵活地定义。</li>
</ul>
<p><strong>与传统方法的对比:</strong></p>
<ul>
<li><strong>异常处理</strong>: 传统的异常处理（如 C++ <code>throw</code>/<code>catch</code>, Java <code>try</code>/<code>catch</code>）只能单向地将控制权向上传递，并且通常难以恢复到抛出点。代数效应的处理器可以选择<strong>恢复 (resume)</strong> Callee 的执行。</li>
<li><strong>状态传递/Monad</strong>: 手动传递状态或使用 Monad 会将副作用的处理逻辑侵入到函数签名和实现中，降低代码的直接性和可组合性。代数效应将效应处理逻辑与核心计算逻辑解耦。</li>
</ul>
<p><strong>2. 声明效应 (<code>effect</code>)</strong></p>
<p>要使用代数效应，首先需要声明它们。我们使用 <code>effect</code> 关键字来定义一个新的效应操作，它看起来有点像定义一个函数签名：</p>
<pre><code class="language-flurry">-- 声明一个名为 'ask' 的效应，它没有参数，期望返回一个 String
effect ask() -&gt; String;

-- 声明一个名为 'output' 的效应，接收一个 String 参数，不返回值 (void)
effect output(message: String); -- -&gt; void 是默认的

-- 声明一个泛型效应 'read_state'，读取类型为 T 的状态
-- T 必须实现 Default trait (提供默认值)
effect read_state() -&gt; T where T:- Default;

-- 声明一个可能失败的效应 'write_file'
-- 它接收路径和数据，返回一个结果，表示成功或一个 IoErr
effect write_file(path: String, data: Slice&lt;u8&gt;) -&gt; !IoErr void;
</code></pre>
<ul>
<li><code>effect &lt;Name&gt;</code>: 定义效应的名称。</li>
<li><code>(...)</code>: 参数列表（可选），定义了发出该效应时需要携带的数据。</li>
<li><code>-&gt; ReturnType</code>: 返回类型（可选，默认为 <code>void</code>），定义了处理器恢复执行时<strong>应该提供</strong>给 Callee 的值的类型。</li>
<li><code>where ...</code>: 泛型约束（可选）。</li>
</ul>
<p>每个 <code>effect</code> 声明定义了一个新的<strong>效应操作签名</strong>。</p>
<p><strong>3. 发出效应</strong></p>
<pre><code class="language-flurry">fn user_interaction() -&gt; #[output, ask] String {
    -- 发出 output 效应，请求打印消息
    output("What is your name?")#;
    -- 发出 ask 效应，请求获取输入，并将处理器返回的值赋给 name
    let name = ask()#;
    "Hello, " + name
}

fn read_default_config() -&gt; #[read_state&lt;Config&gt;] Config {
    -- 发出泛型效应，读取 Config 类型的状态
    let config = read_state&lt;Config&gt;()#;
    config
}
</code></pre>
<p><strong>4. 处理与恢复 (<code>handles</code>, <code>#{...}</code>, <code>resume</code>)</strong></p>
<p>调用者通过安装<strong>效应处理器 (Effect Handler)</strong> 来拦截和处理效应。</p>
<pre><code class="language-flurry">fn run_interaction() {
    -- 调用 user_interaction，并为其安装一个处理器
    let result = user_interaction()# {
        -- 定义 ask 效应的处理分支
        ask() =&gt; {
            print("&gt; "); -- 实际执行输出
            let input = io.read_line(); -- 实际执行输入
            input -- 恢复 user_interaction 的执行，并将 input 作为 ask() 的返回值
        },
        -- 定义 output 效应的处理分支
        output(msg) =&gt; { -- 匹配 output(msg) 效应，并绑定参数 msg
            println(msg); -- 实际执行输出
        }
    }
    println("Final result: {}", result);
}
</code></pre>
<ul>
<li><strong>安装处理器</strong>: <code>expr# { ... }</code> 语法用于安装处理器。<code>expr</code> 是发出效应的表达式，<code>{ ... }</code> 是处理器的定义。</li>
<li><strong>处理器分支</strong>: 处理器对效应调用进行模式匹配。每个分支定义了如何处理特定的效应。</li>
<li><strong>恢复执行</strong>: <code>resume</code> 语句用于将处理器的结果返回给 Callee。通常，处理器会在分支中直接返回值（如 <code>input</code>），而不需要显式地使用 <code>resume</code>。但在某些情况下，可能需要使用 <code>resume</code> 来明确恢复执行。</li>
<li><strong>处理器的返回值</strong>: 处理器的返回值会被传递给发出效应的函数（Callee），作为该效应的返回值。</li>
</ul>
<p><strong>5. 代数效应的类型签名 (<code>#EffectList Type</code>)</strong></p>
<p>就像错误处理有 <code>!Errors T</code> 类型签名一样，代数效应也需要在函数签名中声明函数<strong>可能</strong>发出的效应。这有助于静态分析和保证效应被处理。</p>
<ul>
<li>
<p><strong>语法</strong>: <code>#EffectList Type</code>，其中 <code>EffectList</code> 是一个编译时已知的效应列表（可能包含具体效应或泛型效应）。</p>
</li>
<li>
<p><strong>示例</strong>:</p>
<pre><code class="language-flurry">-- 这个函数可能发出 ask 和 output 效应，并最终返回 String
fn user_interaction() -&gt; #[output, ask] String;

fn read_default_config() -&gt; #[read_state&lt;T&gt;] T where T:- Default;

fn pure_add(a: i32, b: i32) -&gt; #[] i32; -- 或者简写为 -&gt; i32
</code></pre>
</li>
<li>
<p><strong>效应检查</strong>: 编译器会检查函数体内部的效应调用是否与签名中声明的 <code>EffectList</code> 兼容。</p>
</li>
<li>
<p><strong>Handler 消融规则 (Handler Elimination)</strong>: 设效应处理器可处理的效应集为A, 计算的效应集为B，则将处理器应用与计算后，计算剩余的效应集为B - A。也就是说，处理器会消解掉它所处理的效应，使得最终的计算结果不再携带这些效应。这与错误处理的消减规则类似。</p>
<pre><code class="language-flurry">fn run_interaction() -&gt; #[] void { -- run_interaction 本身不发出效应
    -- user_interaction 的类型是 -&gt; #[output, ask] String
    let result = user_interaction()# { -- 安装处理器
        ask() =&gt; { ... },
        output(msg) =&gt; { ... },
    }
    println("Final result: {}", result);
}
</code></pre>
<p>这种效应消解规则对于类型系统的健全性和模块化推理至关重要。</p>
</li>
</ul>
<p><strong>6. 为类型定义处理某些 Effect 的能力 (<code>Prefabricated Handlers</code>)</strong></p>
<p>Flurry 提供了一种独特的机制，允许将<strong>效应处理逻辑直接与某个类型关联</strong>起来，这被称为<strong>预制处理器 (Prefabricated Handlers)(我大概得取个好名字)</strong>。这使得该类型的实例能够“预制”处理特定效应的能力。</p>
<pre><code class="language-flurry">-- 假设我们有一个管理状态的 Runtime 类型
struct StateRuntime where T {
    current_state: T,
}

impl StateRuntime&lt;T&gt; where T:- Clone {
    handles write_state(new_state: T) {
        self.current_state = new_state;
    }

    handles read_state() -&gt; T {
        self.current_state.clone()
    }
}

--- 使用预制处理器 ---
fn use_runtime_state(runtime: StateRuntime&lt;T&gt;) -&gt; T where T:- Clone + Default {
    do {
        let state = read_state()#; -- 发出效应
        println("Read state: {any}", state);
        state
    }.use(runtime) -- 指示使用 runtime 的预制处理器
}

test {
    let rt = StateRuntime&lt;i32&gt; { current_state: 10 }
    let val = use_runtime_state(rt); -- val 会是 10
}
</code></pre>
<p><strong>总结</strong></p>
<p>代数效应是 Flurry 区别于许多传统系统级语言的关键特性，有望在并发/异步编程、状态管理、可测试性、DSL 构建等领域带来显著优势。理解代数效应的原理和机制，对于发挥 Flurry 的全部潜力至关重要。</p>
<div style="break-before: page; page-break-before: always;"></div><h2 id="宏系统"><a class="header" href="#宏系统">宏系统</a></h2>
<p>Flurry 不仅仅提供强大的编译时计算能力，还配备了一套层次丰富、功能强大的<strong>宏系统 (Macro System)</strong>。宏允许开发者在编译过程的不同阶段介入，对代码进行转换、生成和分析，极大地扩展了语言的表达能力和抽象能力。Flurry 的宏系统旨在提供从简单的文本替换到复杂的、基于语法的代码生成的全方位元编程支持。本章将详细介绍 Flurry 提供的五种主要宏类型。</p>
<h3 id="1-模板宏-template-macros"><a class="header" href="#1-模板宏-template-macros">1. 模板宏 (Template Macros)</a></h3>
<p><strong>概念:</strong></p>
<p>模板宏是最基础的宏形式，其行为类似于 C/C++ 预处理器中的 <code>#define</code>，主要用于执行简单的<strong>词法单元 (Token)</strong> 替换。它们在<strong>词法分析 (Lexical Analysis)</strong> 阶段早期生效，因此其操作对象是原始的 token 流，而非结构化的语法树。</p>
<p><strong>特性:</strong></p>
<ul>
<li><strong>生效阶段</strong>: 词法分析阶段。</li>
<li><strong>输入/输出</strong>: 接收 token 或 token 序列，输出替换后的 token 序列。</li>
<li><strong>作用域</strong>: 模板宏的定义<strong>仅在当前文件内有效</strong>，且必须在使用之前定义（词法顺序）。</li>
<li><strong>定义方式</strong>: 使用 <code>define</code> 关键字。</li>
</ul>
<p><strong>语法形式:</strong></p>
<p>Flurry 提供了几种 <code>define</code> 形式以适应不同的替换场景：</p>
<ol>
<li>
<p><strong>映射单个 Token 块</strong>:</p>
<pre><code class="language-flurry">define &lt;macro_name&gt;(&lt;param_name&gt;) { &lt;replacement_tokens&gt; }
</code></pre>
<p>将调用时括号内的 token 序列（作为一个整体，绑定到 <code>&lt;param_name&gt;</code>）替换为 <code>&lt;replacement_tokens&gt;</code>。</p>
<pre><code class="language-flurry">-- 定义一个宏，尝试将输入的 token 序列转换为整数
define get_int(tokens) {
    -- $tokens 代表调用时括号内的完整 token 序列
    ($tokens).value.*.to_int()?
}

let js_object = ... ;
-- 调用宏，js_object 被绑定到 tokens 参数
let value = get_int(js_object);
-- 展开后: let value = (js_object).value.*.to_int()?;
</code></pre>
</li>
<li>
<p><strong>映射固定数量的后续 Token</strong>:</p>
<pre><code class="language-flurry">define &lt;macro_name&gt; &lt;N&gt; { &lt;replacement_tokens&gt; }
</code></pre>
<p>将紧跟在宏名称后的 <code>&lt;N&gt;</code> 个 token 替换为 <code>&lt;replacement_tokens&gt;</code>。在替换体中，可以使用 <code>$1</code>, <code>$2</code>, ..., <code>$N</code> 来引用捕获的第 n 个 token。</p>
<pre><code class="language-flurry">-- 定义一个宏，用于生成 getter 方法
define getter 2 { -- 捕获后续 2 个 token
    -- $1 是第一个 token (方法名), $2 是第二个 token (字段名)
    fn $1(*self) {
        self.$2
    }
}

struct Student {
    name: String,
    age: u32,

    -- 应用宏
    $getter get_name name
    $getter get_age age

    -- 展开后: 
    -- fn get_name(*self) { self.name }
    -- fn get_age(*self) { self.age }
}
</code></pre>
</li>
<li>
<p><strong>映射后续 Token 块 (按组)</strong>:</p>
<pre><code class="language-flurry">define &lt;macro_name&gt; ...&lt;N&gt; { &lt;replacement_tokens_per_group&gt; }
</code></pre>
<p>将宏名称后花括号 <code>{}</code> 内的所有 token，按照每 <code>&lt;N&gt;</code> 个一组进行分组，对每一组应用 <code>&lt;replacement_tokens_per_group&gt;</code> 进行替换。在替换体中，同样使用 <code>$1</code> 到 <code>$N</code> 引用组内的 token。</p>
<pre><code class="language-flurry">enum HttpStatus {
    .pattern_defined true,
    .base_type u32,

    -- 定义宏，每 2 个 token 为一组进行处理
    define status ...2 { $1: $2, } -- $1 是状态名, $2 是状态码

    -- 应用宏
    $status {
        ok 200
        not_found 404
        internal_server_error 500
        unauthorized 401
        forbidden 403
    }
    -- 展开后:
    -- ok: 200,
    -- not_found: 404,
    -- internal_server_error: 500,
    -- unauthorized: 401,
    -- forbidden: 403,
}
</code></pre>
</li>
</ol>
<p><strong>适用场景:</strong> 模板宏适用于非常简单的、模式化的代码替换，例如定义常量别名、生成简单的重复代码结构（如 getter）或简化字面量列表的编写。由于它们在词法阶段工作，无法理解语法结构，因此不适用于复杂的代码转换。</p>
<h3 id="2-一类与二类构造宏-construction-macros-type-1--type-2"><a class="header" href="#2-一类与二类构造宏-construction-macros-type-1--type-2">2. 一类与二类构造宏 (Construction Macros: Type 1 &amp; Type 2)</a></h3>
<p><strong>概念:</strong></p>
<p>构造宏是 Flurry 宏系统中更强大的成员，它们在<strong>语法分析 (Parsing)</strong> 阶段生效。与模板宏处理原始 token 不同，构造宏能够理解和操作<strong>语法结构</strong>。它们由<strong>编译时 Flurry (<code>comptime flurry</code>)</strong> 代码定义，在语法分析过程中被编译器调用执行，其输出会替换原来的宏调用点。Flurry 提供了两种主要的构造宏类型：</p>
<ul>
<li><strong>一类构造宏 (Macro Type 1)</strong>: 直接操作 Flurry 抽象语法树 (AST)。</li>
<li><strong>二类构造宏 (Macro Type 2)</strong>: 使用 PEG 解析器定义自定义语法，然后操作该自定义语法树。</li>
</ul>
<p><strong><code>TokenBuffer</code>：宏的输入与输出媒介</strong></p>
<p>在讨论构造宏之前，需要了解 <code>TokenBuffer</code>。它是 Flurry 宏系统（特别是构造宏和后续类型）用于传递代码片段的核心数据结构，其本质是一个Token序列。</p>
<ul>
<li><strong>构造</strong>: 使用双花括号 <code>{{ ... }}</code> 语法构造一个 <code>TokenBuffer</code>。</li>
<li><strong>插值</strong>: 可以在 <code>{{ ... }}</code> 内部使用 <code>$</code> 符号插入实现了 <code>TryInto&lt;meta.ast.TokenBuffer&gt;</code> 的值。这包括：
<ul>
<li>Flurry AST 节点 (来自 <code>meta.ast</code> 模块)。</li>
<li>用户通过 PEG 定义的新语法树节点。</li>
<li>另一个 <code>TokenBuffer</code>。
编译器会自动处理将这些值“降级”或序列化回 token 流的过程。</li>
</ul>
</li>
</ul>
<p><strong>一类构造宏 (<code>macro1</code>)</strong></p>
<ul>
<li><strong>输入</strong>: Flurry <strong>抽象语法树 (AST)</strong> 节点列表 (具体类型取决于宏调用的上下文和宏定义)。</li>
<li><strong>处理</strong>: 由一个 <code>comptime fn</code> 实现，接收 AST 节点列表作为参数。</li>
<li><strong>输出</strong>: 返回一个 <code>TokenBuffer</code>。</li>
<li><strong>定义</strong>: 使用<code>meta.macro1</code>宏定义一个一类构造宏。</li>
<li><strong>调用</strong>: 通常使用 <code>@macro_name(...)</code> 或类似语法，括号内的内容会被解析为 Flurry AST 并传递给宏。</li>
</ul>
<pre><code class="language-flurry">-- @macro_name(arg1, arg2, ...) 调用语法
const pattern_matches = macro1' {
    -- 接收一个 Pattern 节点列表，每个节点代表一个 Flurry Pattern
    fn(...patterns: Repetition&lt;meta.ast.FlurryPattern&gt;) -&gt; TokenBuffer {
        -- 使用 Flurry 的 comptime list 操作构建组合模式
        let combined_pattern_ast = patterns.fold({{ not _ }}, |acc_ast, pattern_ast| {{ $acc or $pattern_ast }});

        -- {{ $ast_node }} 会将 AST 节点序列化回 token
        {{ $combined_pattern_ast =&gt; }} -- 生成 `pattern =&gt;` 的 token 序列
    }
}

test {
    let word = "yes";
    if word is {
        -- @ 调用宏，"yes", "Y" 等会被解析为 Flurry String Literal Pattern AST
        @pattern_matches("yes", "Y", "y", "\n") println("yes"),
        -- 展开后: not _ or "yes" or "Y" or "y" or "\n" =&gt; println("yes"),
        @pattern_matches("no", "N", "n") println("no"),
        _ =&gt; println("unknown"),
    }
}
</code></pre>
<p><strong>二类构造宏 (<code>macro2</code>)</strong></p>
<ul>
<li><strong>输入</strong>: 宏调用点花括号 <code>{}</code> 内的<strong>原始 <code>TokenBuffer</code></strong>。</li>
<li><strong>PEG 解析</strong>: 宏定义需要<strong>提供一个 PEG (Parsing Expression Grammar)</strong> 规则来解析输入的 <code>TokenBuffer</code>。
<ul>
<li><strong>PEG 简介</strong>: PEG 是一种形式化的语法表示方法，特别适合用于描述编程语言语法和构建解析器。与传统的上下文无关文法 (CFG) 不同，PEG 的选择操作符 <code>/</code> 是<strong>有序选择 (prioritized choice)</strong>，它消除了文法的歧义性，使得解析过程更直接（通常是递归下降）。PEG 由一系列<strong>解析表达式 (Parsing Expressions)</strong> 组成，用于精确定义如何匹配和消耗输入序列。常见的 PEG 组合子包括：
<ul>
<li><strong>字面量 (<code>'text'</code>)</strong>: 匹配精确的文本。</li>
<li><strong>字符类 (<code>[a-z]</code>)</strong>: 匹配范围内的字符。</li>
<li><strong>序列 (<code>e1 e2</code>)</strong>: 顺序匹配 <code>e1</code> 和 <code>e2</code>。</li>
<li><strong>有序选择 (<code>e1 / e2</code>)</strong>: 优先尝试匹配 <code>e1</code>，如果失败则尝试 <code>e2</code>。</li>
<li><strong>重复 (<code>e*</code>, <code>e+</code>, <code>e?</code>)</strong>: 匹配零次或多次、一次或多次、零次或一次。</li>
<li><strong>谓词 (<code>&amp;e</code>, <code>!e</code>)</strong>: 检查是否能匹配 <code>e</code>（<code>&amp;e</code>，正向预测）或不能匹配 <code>e</code>（<code>!e</code>，负向预测），但不消耗输入。</li>
</ul>
</li>
</ul>
</li>
<li><strong>处理</strong>: 宏定义的 <code>comptime fn</code> 接收由 PEG 解析输入 <code>TokenBuffer</code> 后生成的<strong>自定义语法树</strong>作为参数。</li>
<li><strong>输出</strong>: 返回一个 <code>TokenBuffer</code>。</li>
<li><strong>定义</strong>: 使用 <code>' { peg_rule; fn(parsed_ast) -&gt; TokenBuffer { ... } }</code> 语法，并标记为 <code>macro2</code>。<code>peg_rule</code> 可以是内联定义的 PEG，也可以引用预定义的 PEG 规则（如 Flurry 内置的 <code>FlurryExtendedStatement</code>）。</li>
<li><strong>调用</strong>: 使用 <code>expr' { ... }</code> 语法。花括号内的内容将作为 <code>TokenBuffer</code> 传递给宏。</li>
</ul>
<pre><code class="language-flurry">use meta.ast.*;
const time = macro2' {
    -- 使用类型编码peg规则
    -- newtype KPrint = Keyword&lt;"print"&gt;,
    -- newtype MyPrint = KPrint ~ FlurryExpression,
    -- 常见的组合子有Alternative, Sequence, Repetition, Optional, `~`为Sequence的语法糖
    
    -- 复用已有的语句定义，并且是拓展语句（不只是简单语句）
    newtype Main = Repetition&lt;FlurryExtendedStatement&gt;,
    
    
    fn(statements: Repetition&lt;meta.ast.FlurryExtendedStatement&gt;) -&gt; TokenBuffer {
        -- 可以在处理脚本中进行一些操作
        -- 通过code template来插入语法树，自动根据插入的语法树类型lower到token buffer
        {{
            let __start = Duration.now();
            $statements
            let __end = Duration.now();
            analyze(__start, __end);
        }}
    }
}

test `time macro` {
    let x = 0;
    -- 调用宏，花括号内的代码作为 TokenBuffer 输入
    time' {
        for i in 0..1000000 {
            x += i;
        }
        println("Loop finished"); -- 可以包含多条语句
    }
    -- 展开后 (概念上):
    -- {
    --     let __start = std.time.Instant.now();
    --     for i in 0..1000000 {
    --         x += i;
    --     }
    --     println("Loop finished");
    --     let __end = std.time.Instant.now();
    --     std.debug.analyze_duration(__start, __end);
    -- }
}
</code></pre>
<p><strong>适用场景:</strong> 构造宏非常强大，适用于需要理解和转换代码结构的任务：</p>
<ul>
<li><strong>一类宏</strong>: 适用于你想直接操作标准 Flurry 语法结构的情况，例如分析或重组现有的 Flurry 代码模式。</li>
<li><strong>二类宏</strong>: 极其适合创建<strong>嵌入式领域特定语言 (Embedded DSLs)</strong>。你可以定义自己的迷你语言语法（通过 PEG），然后将其无缝嵌入到 Flurry 代码中，宏负责将 DSL 解析并转换为底层的 Flurry 实现代码。<code>time' { ... }</code>、<code>query_one' { ... }</code> 都是二类宏的绝佳应用。</li>
</ul>
<h3 id="3-三类构造宏-macro3"><a class="header" href="#3-三类构造宏-macro3">3. 三类构造宏 (<code>macro3</code>)</a></h3>
<ul>
<li><strong>输入</strong>: 宏调用点花括号 <code>{}</code> 内的<strong>原始 <code>TokenBuffer</code></strong>。</li>
<li><strong>处理</strong>: 由一个标记了 <code>^macro3</code> 的 <code>comptime fn</code> 实现，该函数直接接收 <code>TokenBuffer</code>。它<strong>不使用 PEG 解析</strong>，而是直接对 token 流进行操作（遍历、替换等）。</li>
<li><strong>输出</strong>: 返回一个处理后的 <code>TokenBuffer</code>。</li>
</ul>
<pre><code class="language-flurry">-- 定义一个三类宏，将输入 token 中的标识符转为大写
^macro3 -- 属性标记这是一个三类宏? 或者有其他机制?
comptime fn to_uppercase_macro(tokens: TokenBuffer) -&gt; TokenBuffer {
    tokens.foreach(|t| if t is .id(str) {
        Token.id(str.to_uppercase()) -- 将标识符转换为大写
    } else {
        t
    })
}

-- 调用宏
to_uppercase_macro' {
    const message = "hello world"; -- message 会变成 MESSAGE
    let variable_name = 1;        -- variable_name 会变成 VARIABLE_NAME
}
-- 展开后 (概念上，只改标识符):
-- const MESSAGE = "hello world";
-- let VARIABLE_NAME = 1;
</code></pre>
<p><strong>适用场景:</strong> 三类宏适用于需要对 token 流进行<strong>低级别操作</strong>的场景。</p>
<h3 id="4-四类构造宏-macro4"><a class="header" href="#4-四类构造宏-macro4">4. 四类构造宏 (<code>macro4</code>)</a></h3>
<ul>
<li><strong>输入</strong>: 宏调用点花括号 <code>{}</code> 内的<strong>原始源码字符串 (String)</strong>，完全忽略 Flurry 的词法和语法规则。</li>
<li><strong>处理</strong>: 由一个标记了 <code>^macro4</code> 的 <code>comptime fn</code> 实现，接收 <code>String</code> 作为输入。函数内部负责解析这个字符串（可以使用自定义解析器、外部工具等）。</li>
<li><strong>输出</strong>: 返回一个 <code>TokenBuffer</code>，该 <code>TokenBuffer</code> 必须包含<strong>语法上有效的 Flurry 代码</strong>，后续会被 Flurry 编译器正常处理。</li>
</ul>
<pre><code class="language-flurry">-- 定义一个四类宏，处理自定义的多行字符串格式
^macro4
comptime fn multi_line_string(input: String) -&gt; TokenBuffer { ... }

let lyris = multi_line_string' {
    say you, say me,
    say it for always,
    that s the way it should be.
}
</code></pre>
<p><strong>适用场景:</strong> 四类宏是<strong>终极武器</strong>，用于处理那些<strong>完全不符合 Flurry 标准语法或词法规则</strong>的输入。它允许你：</p>
<ul>
<li>完全实现自己的lexer、parser</li>
<li>嵌入对<strong>格式敏感</strong>（如缩进）的 DSL。</li>
<li>处理包含大量特殊字符、不需要 Flurry 转义的文本块（类似 <code>builtin.raw_str</code> 但带有自定义解析）。</li>
<li>直接从其他格式（如 CSV, JSON, YAML 等，如果需要内联且不想用运行时库）生成 Flurry 代码。</li>
</ul>
<p><strong>总结</strong></p>
<p>Flurry 的宏系统提供了一个从简单到复杂的<strong>分层结构</strong>，允许开发者在编译过程的不同阶段、以不同的抽象层次（Token, Flurry AST, 自定义 AST, 原始字符串）进行元编程：</p>
<ul>
<li><strong>模板宏</strong>: 快速简单的词法替换。</li>
<li><strong>一类构造宏</strong>: 基于 Flurry AST 的结构化转换。</li>
<li><strong>二类构造宏</strong>: 基于 PEG 的自定义 DSL 解析和代码生成。</li>
<li><strong>三类构造宏</strong>: 基于 TokenBuffer 的底层转换。</li>
<li><strong>四类构造宏</strong>: 基于原始字符串的完全自定义解析和代码生成。</li>
</ul>
<p>这套强大的宏系统，结合 Flurry 的 <code>comptime</code> 计算能力，使得开发者能够极大地提升代码的抽象层次、减少样板代码，并创建出富有表现力的嵌入式 DSL，是 Flurry 语言核心竞争力的重要组成部分。理解并恰当选用不同类型的宏，将是 Flurry 高级编程的关键。</p>
<div style="break-before: page; page-break-before: always;"></div><h2 id="错误处理--可预见且可组合的健壮性-error-handling-predictable-and-composable-robustness"><a class="header" href="#错误处理--可预见且可组合的健壮性-error-handling-predictable-and-composable-robustness">错误处理 —— 可预见且可组合的健壮性 (Error Handling: Predictable and Composable Robustness)</a></h2>
<p>程序在现实世界中难免会遇到各种预期之外的情况——文件没找到、网络连接中断、用户输入格式错误等等。如何优雅、健壮地处理这些“错误”情况，是衡量一门编程语言成熟度的重要标准。Flurry 在这方面下足了功夫，它利用其富有表现力的类型系统和专门的语法，提供了一套<strong>可预见且高度可组合</strong>的错误处理方案。</p>
<p><strong>1. 表示“可能缺失”：可选类型 (<code>?T</code>)</strong></p>
<p>最简单的“错误”形式就是值的缺失。一个函数可能找到一个结果，也可能找不到。对于这种情况，Flurry 使用<strong>可选类型 (Optional Type)</strong>，在类型前加上问号 <code>?</code> 来表示：</p>
<pre><code class="language-flurry">-- 查找用户，可能找到 (User)，也可能找不到 (null)
fn find_user(id: Uuid) -&gt; ?User {
    -- ... 查询逻辑 ...
    if found {
        user -- 自动提升为 ?User (Some(user))
    } else {
        null -- 表示缺失
    }
}

test {
    let user_opt = find_user(some_id);
    -- 处理可选值通常用模式匹配
    if user_opt is {
        user? =&gt; println("Found user: {}", user.name),
        null =&gt; println("User not found."),
    }

    let user_name = find_user(some_id)?.name.unwrap_or("Unknown");
}
</code></pre>
<ul>
<li><code>?T</code> 类型表示一个值要么是 <code>T</code> 类型，要么是表示“无”的 <code>null</code>。</li>
<li>处理 <code>?T</code> 通常使用模式匹配 (<code>if is { some? =&gt; ..., null =&gt; ... }</code>) 来安全地访问其内部值。</li>
<li>这避免了 C/C++ 中空指针解引用的风险，强制开发者处理值可能缺失的情况。</li>
</ul>
<p><strong>2. 表示“可能失败”：错误联合类型 (<code>!ErrorType ResultType</code>)</strong></p>
<p>当一个操作不仅可能缺失结果，还可能因为<strong>特定原因</strong>失败时，我们需要更精确地表达“哪种错误”发生了。Flurry 使用感叹号 <code>!</code> 前缀来定义<strong>错误联合类型 (Error Union Type)</strong>：</p>
<pre><code class="language-flurry">-- 读取配置文件，可能成功返回 Config，也可能因 NetErr 失败
fn load_config_from_network(url: String) -&gt; ![NetErr, ParseErr] Config {
    let response = http.get(url)!;
    parse(response)!; -- 可能失败
}

-- 调用点处理
let config_result = load_config_from_network("...")! {
    -- this catch branch runs before all other branches
    catch e =&gt; println("Error loading config: {}", e'tag_name),

    .ParseErr.RequiredFieldMissing(info) =&gt; println("Missing required field: {}", info),
    .NetErr.Timeout =&gt; println("Network timeout!"),
    .NetErr.ConnectionRefused =&gt; println("Connection refused!"),
    .NetErr.* =&gt; println("Other network error."),
    .ParseErr.* =&gt; println("Other parse error."),

    -- this catch branch runs after all other branches
    catch e =&gt; panic("Unhandled error: {}", e'tag_name),
}
</code></pre>
<p><strong>3. 组合多种错误：层级化枚举与枚举融合</strong></p>
<p>一个复杂的操作往往可能因为<strong>多种不同来源</strong>的错误而失败。例如，处理用户上传的文件可能遇到网络错误、文件系统错误、解析错误等等。为每种组合都定义一个新的错误类型会非常繁琐。Flurry 利用其强大的<strong>层级化枚举</strong>和<strong>枚举融合</strong>特性来优雅地解决这个问题：</p>
<ul>
<li>
<p><strong>库定义各自的错误枚举</strong>:</p>
<pre><code class="language-flurry">-- network_lib
enum NetErr {
    Timeout,
    ConnectionRefused,
    InvalidResponse,
    Unauthorized,
    ...
}
-- filesystem_lib
enum FsErr {
    NotFound(path: fs.Path),
    PermissionDenied(path: fs.Path),
    DiskFull(path: fs.Path),
    ...
}
-- parser_lib
enum ParseErr {
    InvalidFormat(location: Location),
    RequiredFieldMissing(field: String),
    FieldTypeMismatch(field: String, expected: String, actual: String),
}
</code></pre>
</li>
<li>
<p><strong>函数签名中使用错误列表</strong>: 函数签名可以列出所有<strong>可能</strong>发生的错误类型。</p>
<pre><code class="language-flurry">-- 这个函数可能返回 Data，或者失败并返回 FsErr 或 ParseErr 中的任何一种
fn process_local_file(path: String) -&gt; ![FsErr, ParseErr] Data {
    let content = fs.read(path)!; -- '!' 传播 FsErr
    let data = parser.parse(content)!; -- '!' 传播 ParseErr
    data
}
</code></pre>
</li>
<li>
<p><strong>融合类型消减规则 (Error Fusion Reduction)</strong>: 设错误处理器可处理的效应集为A, 数据的效应集为B，则将处理器应用与计算后，数据剩余的错误集为B - A。也就是说，处理器会消解掉它所处理的错误，使得最终的计算结果不再携带这些错误。</p>
<pre><code class="language-flurry">fn complex_operation() -&gt; ![FsErr, ParseErr, NetErr] Data {
    let path = network.download_path()!;
    let data = process_local_file(path)!;
    data
}
</code></pre>
<p>这个消减规则使得错误处理流更加精确和可静态分析。</p>
</li>
</ul>
<p><strong>4. 为类型定义错误处理能力 (<code>handles error [...] -&gt; A { ... }</code>)</strong></p>
<p>类似于代数效应的预制处理器，Flurry 也可能提供一种方式，让类型能够<strong>预定义</strong>处理<strong>特定错误类型集合</strong>的方法。这可以用于实现自定义的错误恢复策略或将错误转换为另一种形式。</p>
<ul>
<li><strong>语法</strong>:
<pre><code class="language-flurry">struct SrcManager {
    -- 实际上，我们让这个处理器更像一个中间件
    handles error [FsErr, ParseErr] -&gt; ParseErr {
        .FsErr.NotFound(path) =&gt; println("File not found: {}", path),
        .ParseErr.UnexpectedToken(span, expected, context, actual, note) =&gt;
            self.report(
                .err,
                span,
                fmt.format("unexpected token `{}`, found {}, when parsing {}", self.src_content(actual), expected, context),
                note,
                .extra_lines = 3,
            )
        ...
    }
}

test {
    -- ![ParseErr] Ast == !ParseErr Ast
    -- parse: fn(String) -&gt; ![ParseErr] Ast
    -- parse(src).use(SrcManager): ![ParseErr] Ast
    -- parse(src).use(SrcManager)!: Ast
    let ast = parse(src).use(SrcManager)!;
}
</code></pre>
</li>
</ul>
<p><strong>总结</strong></p>
<p>Flurry 的错误处理系统巧妙地结合了多种机制，旨在实现类型安全、可组合和富有表现力的错误管理，避免了 C 的错误码、Java 的检查异常（带来的样板代码）和 Go 的 <code>if err != nil</code>（重复代码）的许多缺点，同时提供了比 Rust（需要手动定义错误枚举或使用 <code>anyhow</code>/<code>thiserror</code>）更原生的多错误组合能力。它使得编写健壮的系统级代码变得更加容易和可靠。</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="模块系统与包管理"><a class="header" href="#模块系统与包管理">模块系统与包管理</a></h1>
<div style="break-before: page; page-break-before: always;"></div><h1 id="模块定义与组织-mod-mod-file"><a class="header" href="#模块定义与组织-mod-mod-file">模块定义与组织 (mod, mod file)</a></h1>
<div style="break-before: page; page-break-before: always;"></div><h1 id="导入-use"><a class="header" href="#导入-use">导入 (use)</a></h1>
<div style="break-before: page; page-break-before: always;"></div><h1 id="包与-packagefl"><a class="header" href="#包与-packagefl">包与 package.fl</a></h1>
<div style="break-before: page; page-break-before: always;"></div><h1 id="属性系统-attributes"><a class="header" href="#属性系统-attributes">属性系统 (Attributes)</a></h1>
<div style="break-before: page; page-break-before: always;"></div><h1 id="语法-expr-symbol"><a class="header" href="#语法-expr-symbol">语法 (^expr, .symbol)</a></h1>
<div style="break-before: page; page-break-before: always;"></div><h1 id="编译时配置与反射"><a class="header" href="#编译时配置与反射">编译时配置与反射</a></h1>
<div style="break-before: page; page-break-before: always;"></div><h1 id="库扩展应用"><a class="header" href="#库扩展应用">库扩展应用</a></h1>
<div style="break-before: page; page-break-before: always;"></div><h1 id="flurry-的安全哲学"><a class="header" href="#flurry-的安全哲学">Flurry 的安全哲学</a></h1>
<div style="break-before: page; page-break-before: always;"></div><h1 id="safe-flurry-的保证"><a class="header" href="#safe-flurry-的保证">safe Flurry 的保证</a></h1>
<div style="break-before: page; page-break-before: always;"></div><h1 id="仿射类型与可达性系统回顾"><a class="header" href="#仿射类型与可达性系统回顾">仿射类型与可达性系统回顾</a></h1>
<div style="break-before: page; page-break-before: always;"></div><h1 id="unsafe-flurry"><a class="header" href="#unsafe-flurry">unsafe Flurry</a></h1>
<div style="break-before: page; page-break-before: always;"></div><h1 id="必要性与风险"><a class="header" href="#必要性与风险">必要性与风险</a></h1>
<div style="break-before: page; page-break-before: always;"></div><h1 id="验证-unsafe-代码"><a class="header" href="#验证-unsafe-代码">验证 unsafe 代码</a></h1>
<div style="break-before: page; page-break-before: always;"></div><h1 id="verified-flurry-形式化验证"><a class="header" href="#verified-flurry-形式化验证">verified Flurry: 形式化验证</a></h1>
<div style="break-before: page; page-break-before: always;"></div><h1 id="目标与方法-ml-rl-osl"><a class="header" href="#目标与方法-ml-rl-osl">目标与方法 (ML, RL, OSL)</a></h1>
<div style="break-before: page; page-break-before: always;"></div><h1 id="规范与工作流程"><a class="header" href="#规范与工作流程">规范与工作流程</a></h1>
<div style="break-before: page; page-break-before: always;"></div><h1 id="并发与并行"><a class="header" href="#并发与并行">并发与并行</a></h1>
<div style="break-before: page; page-break-before: always;"></div><h1 id="与外部代码交互-ffi"><a class="header" href="#与外部代码交互-ffi">与外部代码交互 (FFI)</a></h1>
<div style="break-before: page; page-break-before: always;"></div><h1 id="语言设计原理与权衡"><a class="header" href="#语言设计原理与权衡">语言设计原理与权衡</a></h1>
<div style="break-before: page; page-break-before: always;"></div><h1 id="未来展望与社区参与"><a class="header" href="#未来展望与社区参与">未来展望与社区参与</a></h1>
<div style="break-before: page; page-break-before: always;"></div><h1 id="语法速查表"><a class="header" href="#语法速查表">语法速查表</a></h1>
<div style="break-before: page; page-break-before: always;"></div><h1 id="关键字参考"><a class="header" href="#关键字参考">关键字参考</a></h1>
<div style="break-before: page; page-break-before: always;"></div><h1 id="内置属性参考"><a class="header" href="#内置属性参考">内置属性参考</a></h1>
<div style="break-before: page; page-break-before: always;"></div><h1 id="内置-像-参考"><a class="header" href="#内置-像-参考">内置 "像" 参考</a></h1>
<div style="break-before: page; page-break-before: always;"></div><h1 id="词汇表"><a class="header" href="#词汇表">词汇表</a></h1>

                    </main>

                    <nav class="nav-wrapper" aria-label="Page navigation">
                        <!-- Mobile navigation buttons -->


                        <div style="clear: both"></div>
                    </nav>
                </div>
            </div>

            <nav class="nav-wide-wrapper" aria-label="Page navigation">

            </nav>

        </div>




        <script>
            window.playground_copyable = true;
        </script>


        <script src="elasticlunr.min.js"></script>
        <script src="mark.min.js"></script>
        <script src="searcher.js"></script>

        <script src="clipboard.min.js"></script>
        <script src="highlight.js"></script>
        <script src="book.js"></script>

        <!-- Custom JS scripts -->

        <script>
        window.addEventListener('load', function() {
            window.setTimeout(window.print, 100);
        });
        </script>

    </div>
    </body>
</html>
