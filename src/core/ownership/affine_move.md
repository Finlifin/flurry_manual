## 仿射类型与移动语义

Flurry 的核心安全策略之一是其对资源所有权的管理。它借鉴并发展了仿射类型系统 (Affine Type System) 的思想，规定了值的“使用次数”，并以此为基础实现了**移动语义 (Move Semantics)**，从而在没有传统垃圾回收器的情况下自动管理资源（如内存、文件句柄等）的生命周期。

### `Once`, `Clone`, `Copy`: 类型能力层次

在 Flurry 中，所有类型都隐式地属于一个能力层次，决定了它们的值可以如何被使用和复制：

1.  **`Once` Trait (基础能力)**:
    *   **所有类型**都自动具备 `Once` 能力。这从概念上标记了一个值**可以被销毁或最终使用一次**。它更像是一个逻辑基础，表明每个值都有其生命周期的终点。对于实际编程而言，更重要的是 `Copy` 和 `Clone` 的缺失或存在。

2.  **`Clone` Trait (可克隆)**:
    *   如果一个类型需要能够创建其值的**深拷贝 (Deep Copy)**（即创建一个完全独立的、拥有自己资源的新副本），它可以实现 `Clone` Trait。
    *   实现 `Clone` 通常需要显式地编写 `.clone()` 方法来定义克隆逻辑。
    *   `Clone` 的实例可以被多次使用——通过显式调用 `.clone()` 来创建新的所有权实例。

3.  **`Copy` Trait (可按位复制)**:
    *   `Copy` 是 `Clone` 的一个特殊子集。如果一个类型的克隆操作仅仅是**简单的按位复制 (Bitwise Copy)**，并且复制后原始值仍然有效（即类型不拥有需要特殊释放的资源，如堆内存指针、文件句柄），那么它可以实现 `Copy` Trait。
    *   **常见 `Copy` 类型**: 包括基本类型（如整数 `i32`, 浮点数 `f64`, 布尔 `bool`, 字符 `char`）、只包含 `Copy` 类型字段的结构体或元组，以及某些引用类型（如 `*T`，指针本身的复制是按位复制，但不复制指向的数据）。
    *   **隐式复制**: `Copy` 类型的值在赋值、函数参数传递（按值）或函数返回时，会**自动进行按位复制**。原始值和新副本都是有效的、独立的值。
    *   **无需实现 `Clone`**: 实现了 `Copy` 的类型通常不再需要手动实现 `Clone`，因为简单的位复制就是其克隆方式（编译器可能会自动提供）。

### 移动语义 (Move Semantics)

**核心规则**: 对于**没有**实现 `Copy` Trait 的类型（通常称为“移动类型”或“非 `Copy` 类型”），当它们的值被用在所有权转移的场景时，所有权会从源“移动”到目标，源将**不再有效**。

**所有权转移场景**:

1.  **赋值 (`let new_owner = old_owner;`)**:
    ```flurry
    let s1 = String.from("hello"); -- String 通常不是 Copy 类型
    let s2 = s1; -- s1 的所有权移动到 s2
    -- println(s1); -- 编译错误！s1 不再拥有值，其绑定失效
    println(s2); -- OK
    ```

2.  **函数参数传递 (按值)**:
    ```flurry
    fn takes_ownership(some_string: String) {
        println(some_string);
    } -- some_string 在这里离开作用域，其拥有的资源被 drop

    let message = String.from("world");
    takes_ownership(message); -- message 的所有权移动到函数参数 some_string
    -- println(message); -- 编译错误！message 不再有效
    ```

3.  **函数返回值**:
    ```flurry
    fn creates_string() -> String {
        let s = String.from("new string");
        s -- 返回 s，所有权从 s 移动到函数调用者
    }

    let my_string = creates_string(); -- my_string 接收了函数返回的 String 的所有权
    println(my_string); -- OK
    ```

**仿射类型：“至多使用一次”**

移动语义是仿射类型系统规则的直接体现：一个非 `Copy` 的值，其所有权在任意时刻只能存在于一个地方。一旦所有权转移（被“移动”），原来的绑定就不能再被用来访问这个值了。你可以认为这个值被“消耗”了。

**为什么需要移动语义/仿射类型？**

*   **资源安全**: 这是 Flurry 自动管理资源的关键。对于持有堆内存、文件句柄、网络连接等资源的值，移动语义确保了**只有一个所有者**负责在适当的时候释放这些资源（通常通过 `drop` 机制）。它从根本上防止了**二次释放 (Double Free)** 错误。
*   **数据竞争预防 (基础)**: 虽然完整的线程安全还需要其他机制，但所有权转移有助于防止多个线程同时持有对同一份可变数据（非 `Copy` 类型通常是可变的或包含可变部分）的写入权限。
*   **性能**: 避免了不必要的深拷贝。对于大型数据结构，移动通常比克隆高效得多（通常只是栈上指针或元数据的复制）。

**总结**:

Flurry 通过 `Copy` Trait 区分了可以廉价、安全地进行按位复制的值和那些拥有独特资源所有权的值。对于后者（非 `Copy` 类型），Flurry 强制实行**移动语义**，确保资源所有权的唯一性，这是其内存安全和自动资源管理策略的基础。理解值是 `Copy` 还是 Move（非 `Copy`）对于预测代码行为和避免所有权相关的编译错误至关重要。