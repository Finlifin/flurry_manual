## 基本数据类型

基本数据类型 (Primitive Data Types) 是 Flurry 语言内建的最原子化的数据类型。它们构成了构建所有更复杂数据结构（如结构体、枚举、数组等）的基础。Flurry 提供了一组常见的、面向系统编程需求的基本类型。

*TODO: 以下列表需要基于 Flurry 的最终设计进行确认和完善。*

### 1. 整数类型 (Integer Types)

Flurry 旨在提供一系列固定位宽的整数类型，以进行精确的位级控制：

*   **有符号整数**:
    *   `i8`: 8 位有符号整数
    *   `i16`: 16 位有符号整数
    *   `i32`: 32 位有符号整数
    *   `i64`: 64 位有符号整数
    *   `i128`: 128 位有符号整数 (可选支持)
    *   `isize`: 指针大小的有符号整数（其位宽与目标平台的指针位宽相同，通常是 32 位或 64 位）。常用于索引和大小计算。
*   **无符号整数**:
    *   `u8`: 8 位无符号整数 (常用于表示字节)
    *   `u16`: 16 位无符号整数
    *   `u32`: 32 位无符号整数
    *   `u64`: 64 位无符号整数
    *   `u128`: 128 位无符号整数 (可选支持)
    *   `usize`: 指针大小的无符号整数。是数组索引、集合大小、内存偏移量等的首选类型。

### 2. 浮点数类型 (Floating-Point Types)

用于表示带有小数的数值，遵循 IEEE 754 标准：

*   `f32`: 32 位单精度浮点数。
*   `f64`: 64 位双精度浮点数。

浮点数支持标准的算术运算。需要注意浮点数运算的精度问题和特殊值（如 `f64.NaN`, `f64.Infinity`）。

### 3. 布尔类型 (Boolean Type)

*   `bool`: 表示逻辑值，只有两个可能的取值：`true` 和 `false`。
    常用于条件判断和逻辑运算 (`and`, `or`, `not`)。

### 4. 字符类型 (Character Type)

*   `char`: 表示一个 Unicode 标量值 (Unicode Scalar Value)。它的大小通常是 32 位（以容纳所有 Unicode 标量值），但具体实现可能有所不同。用于表示单个字符。

### 5. `void` 类型 (Unit Type)

*   `void`: 这个类型只有一个值（即unit `()`）。它用于表示函数不返回任何有意义的值，或者用于泛型编程中表示空占位符。

### 6. 指针类型 (Pointer Types)

Flurry 提供了对指针的底层访问能力（尤其在 `unsafe` 上下文中），预计包含：

*   `*T`: 指向类型 `T` 的**不可变**原始指针 (Raw Pointer)。

原始指针的操作（解引用、算术）通常被认为是 `unsafe` 的，因为编译器不保证它们指向有效的内存或没有别名冲突。Flurry 的可达性类型系统和副作用系统旨在配合这些指针类型，提供比 C/C++ 更强的（即使在 `unsafe` 中）分析和潜在保证。

### 7. 编译时特定类型 (Compile-time Specific Types)

Flurry 的 `comptime` 世界可能还包含一些特殊的编译时类型：

*   **`Type`**: 代表类型的类型。用于泛型、反射和编译时元编程。
*   **`str` (编译时)**: 字符串字面量的编译时类型，代表已知的文本内容。
*   **`Symbol`**: 符号类型 (`.id`)，代表唯一的编译时标识符。
*   **`Integer`, `Real` (编译时)**: 未指定大小的、数学意义上的整数和实数类型，可能在字面量推断或 `comptime` 计算的中间阶段使用，最终会“沉降”为具体的运行时类型。

### 类型推断与注解

Flurry 通常支持类型推断，允许在 `let` 绑定等地方省略类型注解，编译器会根据初始化表达式推断类型。但在函数签名、结构体字段等地方，通常需要显式类型注解。

```flurry
let implicit_int = 42; -- 推断为 i32 (或默认整数类型)
let explicit_float: f64 = 3.14;
```

理解这些基本类型及其特征是构建任何 Flurry 程序的基础。它们提供了操作数据和表达计算所需的基本构件。